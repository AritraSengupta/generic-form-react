{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/utils/ValidationUtils.js","../../src/utils/Common.js","../../src/utils/FormUtils.js","../../src/utils/BaseFormConfig.js","../../src/components/Calendar/Month.js","../../src/components/Calendar/MonthYearPicker.js","../../src/components/Calendar/DatePicker.js","../../src/components/FormDisplay.js","../../src/components/Form.js","FormConfig.js","AsyncSearchExample.js","ConditionalFormBasic.js","ConditionalFormAdvanced.js","App.js","index.js"],"names":["Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","standardValidators","required","value","state","message","maxLength","minLength","number","Number","max","min","pattern","RegExp","regPattern","validateValue","validator","Error","runValidationAgainstAllValues","values","Array","error","i","runValidation","validators","name","errors","isRequired","v","isValidDate","d","isNaN","getDateString","date","month","year","getErrorList","errorList","Object","valErrors","getDefaultState","props","formData","acc","curr","dynamicOptions","options","callback","loading","BaseFormConfig","this","isDisabledCell","startDisable","endDisable","start","end","currentDate","Date","MonthTable","tableBodyProps","selectedOrCurrent","cellDate","onChange","highlightedDates","disableStart","disableEnd","cells","isDisabled","dayObj","key","content","className","onClick","day","specialSign","getMonthData","lastDate","days","createMonthObject","getHeaderRow","_dayArray","map","style","padding","data","dayString","dayIndex","render","tableData","headerRow","size","textAlign","collapsing","renderBodyRow","React","PropTypes","string","monthData","yearData","MonthPicker","selectedMonth","_clickMonth","onSelectMonth","YearPicker","selectedYear","yearObj","_clickYear","onSelectYear","parseInt","getDateMonthYear","dateValue","providedDate","arr","changeToUSDateStyle","isValidProvidedDate","defaultDate","Changer","label","onPrev","onNext","height","backgroundColor","display","margin","cursor","DatePicker","_monthArray","onDateChange","popupOpen","showMonth","showYear","pickerYear","startDisabledObj","endDisabledObj","startDisabled","endDisabled","getDerivedStateFromProps","propsValue","nextProps","stateValue","prevState","startOld","endOld","newState","shouldComponentUpdate","popupOpenNew","nextState","isEqual","DatePickerHolder","_showYearTable","_showMonthTable","_today","YearPickerHolder","MonthPickerHolder","Picker","Trigger","fluid","icon","iconPosition","_onClick","trigger","on","open","onClose","basic","verticalOffset","Component","FormDisplay","fieldname","checked","hashMap","currValue","selected","multiple","selectedOptions","o","so","currentOption","text","currentErrors","formState","form","s","validatorMap","el","id","getValidatorMap","vm","Promise","hasError","resolve","debounce","componentDidUpdate","updateStateIfPropsChange","prevProps","handleDynamicSearchChange","searchQuery","oldOptions","uniqBy","newOptions","getFormUnit","val","Form","field_name","disabled","data-testid","isMultiple","clearable","selection","search","placeholder","onSearchChange","onAddItem","allowAdditions","dataId","radio","check","renderGrid","gridList","columns","gridRow","j","getFormGridStruct","firstRowLength","actualColumns","divided","padded","Grid","gl","idx","gr","isColumnView","header","list","type","defaultValue","config","object","defaultValues","prevValues","oldFormData","oldErrors","reSyncValues","newDefaultValues","get","getDefaultValues","finalErrors","newErrors","validateForm","formRef","current","updateForm","currentForm","ref","func","ExampleBasicForm","title","checkboxOptions","radioOptions","textarea","dropdown","checkbox","searchFunction","a","setTimeout","AsyncSearchExample","dropdownMul","ConditionalFormBasic","dateDefaultValue","nameDefaultValue","textAreaDefaultValue","dropdownDefaultValue","checkboxDefaultValue","radioDefaultValue","visible","undefined","length","ConditionalFormAdvanced","currValues","currDropdownValue","prevDropdownValue","firstChoice","container","justifyContent","marginTop","formContainer","width","link","marginRight","color","fontWeight","buttonReset","marginLeft","buttonSubmit","separator","headerMap","description","async","conditional1","conditional2","useRef","useState","formType","setFormType","setDefaultValues","exampleForm","asyncExample","conditionalFormBasic","conditionalFormAdvanced","getLinkStyle","linkName","linkSelected","ReactDOM","App","document","getElementById"],"mappings":"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","file":"static/js/main.2febc17f.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * This file contains all the utils regarding the form validation process,\n * We will use the following structure for error:\n * @param error: {\n *  name: <string> 'field name',\n *  state: <boolean> 'true or false',\n *  message: <string> message to be shown to the user in case state is true\n * }\n */\n\nexport const standardValidators = {\n  required: (value) => {\n    if (typeof value === 'number') {\n      return {\n        state: false\n      }\n    }\n    return {\n      state: !(value && value.length),\n      message: 'is required'\n    }\n  },\n\n  maxLength: (value, { maxLength }) => {\n    if (typeof value !== 'string') {\n      return {\n        state: true,\n        message: 'should be a string'\n      }\n    }\n    return {\n      state: value.length > maxLength,\n      message: `can be a maximum length of ${maxLength}`\n    }\n  },\n\n  minLength: (value, { minLength }) => {\n    if (typeof value !== 'string') {\n      return {\n        state: true,\n        message: 'should be a string'\n      }\n    }\n    return {\n      state: value.length < minLength,\n      message: `should be a minimum length of ${minLength}`\n    }\n  },\n\n  number: (value) => ({\n    state: !(typeof value === 'number' && !Number.isNaN(Number(value))),\n    message: 'should be a number'\n  }),\n\n  max: (value, { max }) => ({\n    state: Number(value) > max,\n    message: `cannot be more than ${max}`\n  }),\n\n  min: (value, { min }) => ({\n    state: Number(value) < min,\n    message: `cannot be less than ${min}`\n  }),\n\n  pattern: (value, { pattern, message }) => {\n    const regPattern = new RegExp(pattern)\n    return {\n      state: !regPattern.test(value),\n      message: message || `does not match pattern ${pattern}`\n    }\n  }\n}\n\nexport const validateValue = (value, validator) => {\n  if (typeof validator === 'function') {\n    return validator(value)\n  }\n\n  if (validator.type && standardValidators[validator.type]) {\n    return standardValidators[validator.type](value, validator.params)\n  }\n\n  throw new Error('Not a valid Validator')\n}\n\nexport const runValidationAgainstAllValues = (values, validator) => {\n  if (Array.isArray(values) && values.length) {\n    let error = null\n    for (let i = 0; i < values.length; i += 1) {\n      if (error && error.state) break\n      error = validateValue(values[i], validator)\n    }\n    return error\n  }\n  return validateValue(values, validator)\n}\n\nexport const runValidation = (values, validators, name) => {\n  if (Array.isArray(validators)) {\n    const errors = []\n    validators.forEach((validator) => {\n      const error = runValidationAgainstAllValues(values, validator)\n\n      if (error.state) {\n        errors.push({ name, ...error })\n      }\n    })\n    return errors\n  }\n  const error = runValidationAgainstAllValues(values, validators)\n  return error.state ? [{ name, ...error }] : []\n}\n\nexport const isRequired = (validators) => {\n  if (Array.isArray(validators)) {\n    return validators.some((v) => !!(v && v.type === 'required'))\n  }\n  return !!(validators && validators.type === 'required')\n}\n","export function changeToUSDateStyle(value) {\n  const arr = value.split('-')\n  const usStyle = [arr[1], arr[0], arr[2]].join('-')\n  return usStyle\n}\n\nexport function isValidDate(d) {\n  return d instanceof Date && !isNaN(d)\n}\n\nexport function formatInputIfDate(date) {\n  if (!date || typeof date !== 'string') return date\n  const dateArray = date.split('-')\n  if (dateArray.length === 3 && !isValidDate(new Date(date))) {\n    // Try to format if not a valid date\n    const openApiDate = `${dateArray[2]}-${dateArray[1]}-${dateArray[0]}`\n    const dateObj = new Date(openApiDate)\n    if (isValidDate(dateObj)) {\n      return openApiDate\n    }\n  }\n  return date\n}\n\nexport function getDateString(date, month, year) {\n  return `${date}-${month + 1}-${year}`\n}\n\nexport const getFormattedDate = (date) => {\n  if (!isValidDate(new Date(date))) return date\n\n  const dateObj = new Date(date)\n  return getDateString(\n    dateObj.getDate(),\n    dateObj.getMonth(),\n    dateObj.getFullYear()\n  )\n}\n\nexport const formatToFixed = (value, decimalPlaces, defaultValue) => {\n  const numericalValue = parseFloat(value).toFixed(decimalPlaces)\n  if (!isNaN(numericalValue)) {\n    return numericalValue\n  }\n  return defaultValue\n}\n\nexport const twoDecimals = (value, decimalPoints) => {\n  if (value === 0) return 0\n  const t = value ? `${value}` : ''\n  if (Number(t) < 0 || t === '-') {\n    return ''\n  }\n  const newValue =\n    t.indexOf('.') >= 0\n      ? t.substr(0, t.indexOf('.')) +\n        t.substr(t.indexOf('.'), decimalPoints + 1)\n      : t\n  return newValue\n}\n\nexport const convertToArray = (hashMap) =>\n  Object.keys(hashMap).filter((key) => hashMap[key])\n","import { get, set, uniqBy, has } from 'lodash'\n\nimport { formatInputIfDate } from './Common'\n\n/**\n * @param {*} formData -> the form datastructure object\n * @param {*} formState -> the current state of the form\n * This function returns the default values of the current form in the format which\n * the form understands. Should be used when converting formState to defaultvalue object\n * to be passed to the form\n */\n\nexport const getDefaultValues = (formData, formState) => {\n  const defaultValues = {}\n  formData.forEach((data) => {\n    if (data.type === 'checkbox') {\n      const defaultValue = get(formState, data.dataId, {\n        value: {},\n        selected: []\n      })\n      defaultValues[data.dataId] = {\n        defaultValue\n      }\n      return\n    }\n    if (data.type === 'files') {\n      const defaultValue = get(formState, data.dataId, [])\n      defaultValues[data.dataId] = { defaultValue }\n      return\n    }\n    if (data.type === 'dropdown') {\n      const defaultValue = get(formState, data.dataId, {})\n      let value\n      let options\n      if (data.config && data.config.multiple) {\n        value = (defaultValue && defaultValue.selected) || []\n        if (value.length === 0) {\n          defaultValue.value = []\n          defaultValue.selected = []\n        }\n        options = uniqBy([...(data.options || []), ...value], 'value')\n      } else {\n        const { selected } = defaultValue || {}\n        value = selected ? [selected] : []\n        options = uniqBy([...(data.options || []), ...value], 'value')\n      }\n\n      defaultValues[data.dataId] = {\n        defaultValue,\n        options\n      }\n      return\n    }\n    const defaultValue = get(formState, data.dataId, null)\n    defaultValues[data.dataId] = {\n      defaultValue\n    }\n  })\n  return defaultValues\n}\n\n/**\n *\n * @param {*} formDataFunc: The conditional Form Function\n * @param {*} apiData: apiData of that needs mapped\n * @param {*} dataMap: the datamap to map apidata to formdata\n *\n * returns an object with keys as form ids and value with default values from api\n * NOTE options from dropdown are not mapped\n */\nexport const conditionalFormDefaultValuesGetter = (\n  formDataFunc,\n  apiData,\n  dataMap\n) => {\n  const formData = formDataFunc({})\n  const mappedDefaults = {}\n  formData.forEach((data) => {\n    if (data.type === 'checkbox') {\n      const defaultValue = get(apiData, dataMap[data.dataId], null)\n      if (defaultValue === null || defaultValue === undefined) {\n        // case to handle null values for api calls\n        mappedDefaults[data.dataId] = {\n          defaultValue: null\n        }\n      } else {\n        const value = (defaultValue || []).reduce((acc, curr) => {\n          acc[curr] = true\n          return acc\n        }, {})\n        mappedDefaults[data.dataId] = {\n          defaultValue: {\n            value,\n            selected: defaultValue\n          }\n        }\n      }\n    } else if (data.type === 'files') {\n      const defaultValue = get(apiData, dataMap[data.dataId], [])\n      mappedDefaults[data.dataId] = {\n        defaultValue: {\n          files: defaultValue,\n          deletedFiles: []\n        }\n      }\n    } else if (data.type === 'dropdown') {\n      const defaultValue = get(apiData, dataMap[data.dataId].id, null)\n      if (defaultValue === null || defaultValue === undefined) {\n        // case to handle null api values for api calls\n        mappedDefaults[data.dataId] = {\n          defaultValue: null,\n          options: data.options\n        }\n      } else {\n        const valueLabel = dataMap[data.dataId].value || 'id'\n        const textLabel = dataMap[data.dataId].text || 'name'\n        let value\n        let options\n        if (data.config && data.config.multiple) {\n          const selected =\n            (defaultValue &&\n              defaultValue.map((d) => ({\n                value: d[valueLabel],\n                text: d[textLabel]\n              }))) ||\n            []\n          value = {\n            value:\n              (defaultValue && defaultValue.map((d) => d[valueLabel])) || [],\n            selected\n          }\n          options = uniqBy([...data.options, ...selected], 'value')\n        } else {\n          const selected = {\n            text: defaultValue && defaultValue[textLabel],\n            value: defaultValue && defaultValue[valueLabel]\n          }\n          value = { value: defaultValue && defaultValue[valueLabel], selected }\n          options = uniqBy([...data.options, selected], 'value')\n        }\n        mappedDefaults[data.dataId] = {\n          defaultValue: {\n            ...value\n          },\n          options\n        }\n      }\n    } else {\n      const defaultValue = get(apiData, dataMap[data.dataId], null)\n      mappedDefaults[data.dataId] = {\n        defaultValue\n      }\n    }\n  })\n  return mappedDefaults\n}\n\nexport const defaultValueMapper = (formData, apiData, dataMap) =>\n  formData.map((data) => {\n    if (data.type === 'checkbox') {\n      const defaultValue = get(apiData, dataMap[data.dataId], []) || []\n      const value = defaultValue.reduce((acc, curr) => {\n        acc[curr] = true\n        return acc\n      }, {})\n      return {\n        ...data,\n        defaultValue: { value, selected: defaultValue }\n      }\n    }\n    if (data.type === 'files') {\n      const defaultValue = get(apiData, dataMap[data.dataId], [])\n      return {\n        ...data,\n        defaultValue: { files: defaultValue, deletedFiles: [] }\n      }\n    }\n    if (data.type === 'dropdown') {\n      const defaultValue = get(apiData, dataMap[data.dataId].id, null)\n      const valueLabel = dataMap[data.dataId].value || 'id'\n      const textLabel = dataMap[data.dataId].text || 'name'\n      let value\n      let options\n      if (data.config && data.config.multiple) {\n        const selected =\n          (defaultValue &&\n            defaultValue.map((d) => ({\n              value: d[valueLabel],\n              text: d[textLabel]\n            }))) ||\n          []\n        value = {\n          value: (defaultValue && defaultValue.map((d) => d[valueLabel])) || [],\n          selected\n        }\n        options = uniqBy([...(data.options || []), ...selected], 'value')\n      } else {\n        const selected = {\n          text: defaultValue && defaultValue[textLabel],\n          value: defaultValue && defaultValue[valueLabel]\n        }\n        value = { value: defaultValue && defaultValue[valueLabel], selected }\n        options = uniqBy([...(data.options || []), selected], 'value')\n      }\n      return {\n        ...data,\n        defaultValue: value,\n        options\n      }\n    }\n    const defaultValue = get(apiData, dataMap[data.dataId], null)\n    return {\n      ...data,\n      defaultValue\n    }\n  })\n\nexport const apiDataMapper = (formData, dataMap) => {\n  const apiData = {}\n  Object.keys(formData).forEach((key) => {\n    let formDataValue\n    // Doing it this way ensures that is the selected key is present then the value\n    // inside selected is retured regardless whether its falsy or not\n    if (has(formData, `${key}.selected`)) {\n      formDataValue = formData[key].selected\n    } else if (has(formData, `${key}.files`)) {\n      formDataValue = formData[key].files\n    } else {\n      // Change to OpenAPI spec if the date is in DD-MM-YYYY format\n      formDataValue = formatInputIfDate(formData[key])\n    }\n    const formKey = dataMap[key].id || dataMap[key]\n    set(apiData, formKey, formDataValue)\n  })\n  return apiData\n}\n\nexport const dropdownOptionsMapper = (\n  list,\n  valueLabel = 'id',\n  textLabel = 'name'\n) => {\n  if (!list) return []\n  return list.map((l) => ({\n    text: l[textLabel],\n    value: l[valueLabel]\n  }))\n}\n\nexport const getValidatorMap = (form, formState) =>\n  form.map((el) => {\n    let value = formState[el.dataId]\n    if (value && el.type === 'dropdown') {\n      const { selected } = value\n      if (Array.isArray(selected)) {\n        value = selected.map((s) => s.text)\n      } else {\n        value = selected && selected.text\n      }\n    } else if (value && el.type === 'checkbox') {\n      value = value.selected\n    }\n    return {\n      id: el.dataId,\n      validators: el.validators,\n      value,\n      name: el.fieldname\n    }\n  })\n\nexport const getFormGridStruct = (formData, columns) => {\n  const gridList = []\n  let i = 0\n  while (i < formData.length) {\n    const gridRow = []\n    let j = 0\n    while (j < columns && i < formData.length) {\n      if (formData[i] && formData[i].type !== 'hidden') {\n        gridRow.push(formData[i])\n        j += 1\n      }\n      i += 1\n    }\n\n    if (gridRow.length) {\n      gridList.push(gridRow)\n    }\n  }\n  return gridList\n}\n\nexport const getErrorList = (errors) => {\n  const errorList = []\n  Object.keys(errors).forEach((key) => {\n    const valErrors = []\n    ;(errors[key] || []).forEach((e) => {\n      e.state && valErrors.push(`${e.name}: ${e.message}`)\n    })\n    errorList.push(...valErrors)\n  })\n  return errorList\n}\n\nexport function getDefaultState(props) {\n  return {\n    formData: props.data.reduce((acc, curr) => {\n      acc[curr.dataId] = curr.defaultValue\n      return acc\n    }, {}),\n    errors: props.errors || {},\n    dynamicOptions: props.data.reduce((acc, curr) => {\n      if (curr.type === 'dropdown' && curr.config && curr.config.search) {\n        acc[curr.dataId] = {\n          options: curr.options,\n          callback: curr.config.callback,\n          loading: false\n        }\n      }\n      return acc\n    }, {})\n  }\n}\n","export default class BaseFormConfig {\n  constructor(props) {\n    this.props = props\n  }\n\n  title = 'Generic Conditional Input Form'\n\n  data = () => []\n\n  reSyncValues = async (values, prevValues, errors) => ({ values, errors })\n}\n","import React from 'react'\nimport { Table } from 'semantic-ui-react'\nimport PropTypes from 'prop-types'\n\nimport { getDateString, isValidDate } from '../../utils'\n\nexport const isDisabledCell = (date, month, year, startDisable, endDisable) => {\n  if (!date) return true\n\n  if (!isValidDate(startDisable) && !isValidDate(endDisable)) return false\n  const start = isValidDate(startDisable) ? startDisable : -Infinity\n  const end = isValidDate(endDisable) ? endDisable : Infinity\n  const currentDate = new Date(year, month, date)\n\n  return currentDate >= start && currentDate <= end\n}\n\n/**\n * type Props = {\n *  onChange: (e: Event, name: string) => void\n *  month: number\n *  year: number\n *  selectedOrCurrent: Date string (DD-MM-YYYY), showing date in blue, useful for showing selection\n *  highlightedDates: Array<{[date: number]: warning | negative | positive | error}>\n *  disableStart: Date string (DD-MM-YYYY), starting date of the disabled dates\n *  disableEnd: Date string(DD-MM-YYYY), ending date of disabled dates\n * }\n *\n * selectedOrCurrent is used to show a selected or current date when using a date picker\n * highlightedDates are to be used in calendar mode when each month is a different instance of the component\n */\n\nexport class MonthTable extends React.Component {\n  _dayArray = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n\n  _monthArray = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n  ]\n\n  getMonthData(month, year) {\n    // Month + 1 because 0th date is last day of prev month\n    const lastDate = new Date(year, month + 1, 0)\n    if (isValidDate(lastDate)) {\n      const days = lastDate.getDate()\n      const day = lastDate.getDay()\n      return this.createMonthObject([{}], day, days)\n    }\n    return null\n  }\n\n  _getClassName = (day, tableBodyProps, disabled) => {\n    const date = tableBodyProps[day] || ''\n    if (!date) return 'compact'\n    if (disabled) return 'compact disabled'\n    const { month, year, selectedOrCurrent } = this.props\n    const cellDate = getDateString(date, month, year)\n    return cellDate === selectedOrCurrent\n      ? 'compact highlight selected'\n      : 'compact highlight'\n  }\n\n  _clickDay = (e) => {\n    const { onChange } = this.props\n    onChange(e, e.target.dataset.name)\n  }\n\n  processCells = (tableBodyProps) => {\n    const {\n      highlightedDates,\n      month,\n      year,\n      disableStart,\n      disableEnd\n    } = this.props\n    const cells = []\n    this._dayArray.forEach((day) => {\n      const isDisabled = isDisabledCell(\n        tableBodyProps[day],\n        month,\n        year,\n        disableStart,\n        disableEnd\n      )\n      const dayObj = {\n        key: day,\n        content: tableBodyProps[day] || '',\n        className: this._getClassName(day, tableBodyProps, isDisabled),\n        onClick: !isDisabled ? this._clickDay : null, // To prevent clicking outside a given date\n        'data-name': tableBodyProps[day]\n      }\n      const specialSign =\n        highlightedDates && highlightedDates[tableBodyProps[day]]\n      if (specialSign) {\n        dayObj[specialSign] = true\n      }\n      cells.push(dayObj)\n    })\n    return cells\n  }\n\n  getHeaderRow() {\n    return {\n      cells: this._dayArray.map((day) => ({\n        key: day,\n        style: { padding: 0 },\n        content: day\n      }))\n    }\n  }\n\n  createMonthObject(data, dayIndex, date) {\n    if (date === 0) return data\n\n    const dayString = this._dayArray[dayIndex]\n\n    // eslint-disable-next-line\n    data[0][dayString] = date;\n\n    if (dayIndex === 0 && date > 1) {\n      data.unshift({})\n      return this.createMonthObject(data, 6, date - 1)\n    }\n\n    return this.createMonthObject(data, dayIndex - 1, date - 1)\n  }\n\n  renderBodyRowNew = (tableBodyProps, i) => ({\n    key: `row-${i}`,\n    cells: this.processCells(tableBodyProps)\n  })\n\n  render() {\n    const { month, year } = this.props\n    const tableData = this.getMonthData(month, year)\n    const headerRow = this.getHeaderRow()\n    if (!tableData) {\n      return <span> Invalid Date </span>\n    }\n    return (\n      <Table\n        size='small'\n        textAlign='center'\n        collapsing\n        headerRow={headerRow}\n        renderBodyRow={this.renderBodyRowNew}\n        tableData={tableData}\n        className='table-month'\n      />\n    )\n  }\n}\n\nMonthTable.propTypes = {\n  month: PropTypes.number,\n  year: PropTypes.number,\n  selectedOrCurrent: PropTypes.string,\n  onChange: PropTypes.func.isRequired,\n  highlightedDates: PropTypes.arrayOf(PropTypes.number),\n  disableStart: PropTypes.string,\n  disableEnd: PropTypes.string\n}\n\nexport default MonthTable\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Table } from 'semantic-ui-react'\n\nconst monthData = [\n  ['Jan', 'Feb', 'Mar'],\n  ['Apr', 'May', 'Jun'],\n  ['Jul', 'Aug', 'Sep'],\n  ['Oct', 'Nov', 'Dec']\n]\n\nconst yearData = (year) => [\n  [year - 7, year - 6, year - 5],\n  [year - 4, year - 3, year - 2],\n  [year - 1, year, year + 1],\n  [year + 2, year + 3, year + 4]\n]\n\nexport class MonthPicker extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this._clickMonth = this._clickMonth.bind(this)\n  }\n\n  processCells = (tableBodyProps) => {\n    const { selectedMonth } = this.props\n    const cells = []\n    tableBodyProps.forEach((month) => {\n      const dayObj = {\n        key: month,\n        content: month || '',\n        className: `compact highlight ${\n          selectedMonth === month ? 'selected' : ''\n        }`,\n        onClick: this._clickMonth,\n        'data-name': month\n      }\n      cells.push(dayObj)\n    })\n    return cells\n  }\n\n  renderBodyRowNew = (tableBodyProps, i) => ({\n    key: `row-${i}`,\n    cells: this.processCells(tableBodyProps)\n  })\n\n  _clickMonth(e) {\n    const { onSelectMonth } = this.props\n    onSelectMonth(e.target.dataset.name)\n  }\n\n  render() {\n    return (\n      <Table\n        size='small'\n        textAlign='center'\n        renderBodyRow={this.renderBodyRowNew}\n        tableData={monthData}\n        className='table-month'\n      />\n    )\n  }\n}\n\nMonthPicker.propTypes = {\n  selectedMonth: PropTypes.string,\n  onSelectMonth: PropTypes.func.isRequired\n}\n\nexport class YearPicker extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this._clickYear = this._clickYear.bind(this)\n  }\n\n  _clickYear(e) {\n    const { onSelectYear } = this.props\n    onSelectYear(parseInt(e.target.dataset.name))\n  }\n\n  processCells = (tableBodyProps) => {\n    const { selectedYear } = this.props\n    const cells = []\n    tableBodyProps.forEach((year) => {\n      const yearObj = {\n        key: year,\n        content: year || '',\n        className: `compact highlight ${\n          selectedYear === year ? 'selected' : ''\n        }`,\n        onClick: this._clickYear,\n        'data-name': year\n      }\n      cells.push(yearObj)\n    })\n    return cells\n  }\n\n  renderBodyRowNew = (tableBodyProps, i) => ({\n    key: `row-${i}`,\n    cells: this.processCells(tableBodyProps)\n  })\n\n  render() {\n    const { year } = this.props\n    return (\n      <Table\n        size='small'\n        textAlign='center'\n        renderBodyRow={this.renderBodyRowNew}\n        tableData={yearData(year)}\n        className='table-month'\n      />\n    )\n  }\n}\n\nYearPicker.propTypes = {\n  year: PropTypes.number.isRequired,\n  selectedYear: PropTypes.number,\n  onSelectYear: PropTypes.func.isRequired\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Input, Icon, Popup } from 'semantic-ui-react'\nimport { isEqual } from 'lodash'\n\nimport { MonthTable } from './Month'\nimport { MonthPicker, YearPicker } from './MonthYearPicker'\nimport { isValidDate, getDateString, changeToUSDateStyle } from '../../utils'\n\nimport './DatePicker.css'\n\n/**\n *\n * @param {*} dateValue date input string\n * This functions attempts to convert the input string into a valid date or else tells its an invalid date\n * However if the date is invalid it returns today's day month and year for default placement\n */\nexport const getDateMonthYear = (dateValue) => {\n  // Chaning to US style takes priority\n  let providedDate = new Date(changeToUSDateStyle(dateValue || ''))\n  let isValidProvidedDate = isValidDate(providedDate)\n  if (!isValidProvidedDate) {\n    // Last try\n    providedDate = new Date(dateValue || '')\n    isValidProvidedDate = isValidDate(providedDate)\n  }\n  const defaultDate = isValidProvidedDate ? providedDate : new Date(Date.now())\n  const month = defaultDate.getMonth()\n  const year = defaultDate.getFullYear()\n  const date = defaultDate.getDate()\n\n  return {\n    isValidProvidedDate,\n    date,\n    month,\n    year,\n    value: `${date}-${month + 1}-${year}`\n  }\n}\n\nexport const Changer = ({ label, onPrev, onNext, onClick }) => (\n  <div style={{ height: 20, backgroundColor: 'white' }}>\n    <Icon name='arrow left' onClick={onPrev} className='arrow_icon' />\n    <div\n      style={{ display: 'inline-block', margin: '0 40px', cursor: 'pointer' }}\n      onClick={onClick}\n    >\n      {label}\n    </div>\n    <Icon name='arrow right' onClick={onNext} className='arrow_icon' />\n  </div>\n)\n\n/**\n * Props: {\n *  value(OPTIONAL): date string format (DD-MM-YYYY) to be shown on the input field, default is Date.now()\n *  onDateChange(OPTIONAL): (e: event, {props: Props, value: string}) => void\n * }\n */\nexport default class DatePicker extends React.Component {\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const { value: propsValue, startDisabled, endDisabled } = nextProps\n    const startDisabledObj = getDateMonthYear(startDisabled || null)\n    const endDisabledObj = getDateMonthYear(endDisabled || null)\n    const {\n      value: stateValue,\n      startDisabled: startOld,\n      endDisabled: endOld\n    } = prevState\n    const { isValidProvidedDate, value } = getDateMonthYear(propsValue)\n\n    const newState = {}\n    if (propsValue && propsValue !== stateValue) {\n      newState.value = isValidProvidedDate ? value : propsValue\n    }\n\n    if (startDisabledObj.value !== startOld) {\n      newState.startDisabled = startDisabledObj.isValidProvidedDate\n        ? startDisabledObj\n        : null\n    }\n\n    if (endDisabledObj.value !== endOld) {\n      newState.endDisabled = endDisabledObj.isValidProvidedDate\n        ? endDisabledObj\n        : null\n    }\n\n    return newState\n  }\n\n  _monthArray = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n  ]\n\n  constructor(props) {\n    super(props)\n\n    const { date, month, year, isValidProvidedDate, value } = getDateMonthYear(\n      props.value\n    )\n    const startDisabledObj = getDateMonthYear(props.startDisabled || '')\n    const endDisabledObj = getDateMonthYear(props.endDisabled || '')\n    this.state = {\n      month,\n      year,\n      date,\n      value: isValidProvidedDate ? value : '',\n      popupOpen: false,\n      showMonth: false,\n      showYear: false,\n      pickerYear: year,\n      startDisabled: startDisabledObj.isValidProvidedDate\n        ? startDisabledObj\n        : null,\n      endDisabled: endDisabledObj.isValidProvidedDate ? endDisabledObj : null\n    }\n    this._today = getDateString(date, month, year)\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { value, popupOpen } = this.state\n    const { popupOpenNew } = nextState\n    const { value: newValue } = nextProps\n    return (\n      value !== newValue ||\n      popupOpen !== popupOpenNew ||\n      !isEqual(this.props, nextProps)\n    )\n  }\n\n  _yearPrev = () => {\n    let { year } = this.state\n    year -= 1\n    this.setState({ year })\n  }\n\n  _yearNext = () => {\n    let { year } = this.state\n    year += 1\n    this.setState({ year })\n  }\n\n  _monthNext = () => {\n    let { month, year } = this.state\n    month += 1\n    if (month > 11) {\n      month = 0\n      year += 1\n    }\n    this.setState({ month, year })\n  }\n\n  _monthPrev = () => {\n    let { month, year } = this.state\n    month -= 1\n    if (month < 0) {\n      month = 11\n      year -= 1\n    }\n    this.setState({ month, year })\n  }\n\n  _onDateChange = (e, date) => {\n    const { month, year } = this.state\n    const { onDateChange } = this.props\n    const value = getDateString(date, month, year)\n    if (onDateChange) {\n      onDateChange(e, { ...this.props, value })\n      this.setState({ popupOpen: false })\n    } else {\n      this.setState({ value, date, popupOpen: false })\n    }\n  }\n\n  _onClick = () => {\n    this.setState({ popupOpen: true })\n  }\n\n  _handleClose = () => {\n    this.setState({ popupOpen: false })\n  }\n\n  _showMonthTable = () => {\n    this.setState({ showMonth: true })\n  }\n\n  _hideMonthTable = () => {\n    this.setState({ showMonth: false })\n  }\n\n  _showYearTable = () => {\n    this.setState({ showYear: true })\n  }\n\n  _onSelectMonth = (month) => {\n    this.setState({ month: this._monthArray.indexOf(month), showMonth: false })\n  }\n\n  _onSelectYear = (year) => {\n    this.setState({ year, pickerYear: year, showYear: false })\n  }\n\n  _pickerYearPrev = () => {\n    const { pickerYear } = this.state\n    this.setState({ pickerYear: pickerYear - 12 })\n  }\n\n  _pickerYearNext = () => {\n    const { pickerYear } = this.state\n    this.setState({ pickerYear: pickerYear + 12 })\n  }\n\n  render() {\n    const {\n      month,\n      year,\n      date,\n      value,\n      popupOpen,\n      showMonth,\n      showYear,\n      pickerYear,\n      startDisabled,\n      endDisabled\n    } = this.state\n    const disableStart = startDisabled\n      ? new Date(startDisabled.year, startDisabled.month, startDisabled.date)\n      : null\n    const disableEnd = endDisabled\n      ? new Date(endDisabled.year, endDisabled.month, endDisabled.date)\n      : null\n\n    const DatePickerHolder = (\n      <div className='date_picker_container results transition visible'>\n        <Changer\n          label={year}\n          onPrev={this._yearPrev}\n          onNext={this._yearNext}\n          onClick={this._showYearTable}\n        />\n        <Changer\n          label={this._monthArray[month]}\n          onPrev={this._monthPrev}\n          onNext={this._monthNext}\n          onClick={this._showMonthTable}\n        />\n        <MonthTable\n          disableStart={disableStart}\n          disableEnd={disableEnd}\n          month={month}\n          year={year}\n          date={date}\n          onChange={this._onDateChange}\n          selectedOrCurrent={value || this._today}\n        />\n      </div>\n    )\n\n    const YearPickerHolder = (\n      <div className='date_picker_container results transition visible'>\n        <Changer\n          label={null}\n          onPrev={this._pickerYearPrev}\n          onNext={this._pickerYearNext}\n          onClick={() => null}\n        />\n        <YearPicker\n          onSelectYear={this._onSelectYear}\n          year={pickerYear}\n          selectedYear={year}\n        />\n      </div>\n    )\n\n    const MonthPickerHolder = (\n      <div className='date_picker_container results transition visible'>\n        <MonthPicker\n          onSelectMonth={this._onSelectMonth}\n          selectedMonth={this._monthArray[month]}\n        />\n      </div>\n    )\n\n    let Picker\n    if (showMonth) {\n      Picker = MonthPickerHolder\n    } else if (showYear) {\n      Picker = YearPickerHolder\n    } else {\n      Picker = DatePickerHolder\n    }\n\n    const Trigger = (\n      <Input\n        fluid\n        icon='calendar'\n        iconPosition='left'\n        value={value}\n        onClick={this._onClick}\n      />\n    )\n\n    return (\n      <Popup\n        trigger={Trigger}\n        content={Picker}\n        on='click'\n        open={popupOpen}\n        onClose={this._handleClose}\n        basic\n        style={{ padding: 0 }}\n        verticalOffset={-10}\n      />\n    )\n  }\n}\n\nDatePicker.propTypes = {\n  value: PropTypes.string,\n  startDisabled: PropTypes.string,\n  endDisabled: PropTypes.string,\n  onDateChange: PropTypes.func.isRequired\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Form, Grid, Message } from 'semantic-ui-react'\nimport { debounce, uniqBy, isEqual } from 'lodash'\n\nimport DatePicker from './Calendar/DatePicker'\nimport {\n  getErrorList,\n  getFormGridStruct,\n  getValidatorMap,\n  getDefaultState,\n  convertToArray,\n  runValidation,\n  isRequired\n} from '../utils'\n\nexport default class FormDisplay extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = getDefaultState(props)\n    this.handleDynamicSearchChange = debounce(\n      this.handleDynamicSearchChange.bind(this),\n      500\n    )\n    this.getFormUnit = this.getFormUnit.bind(this)\n    this.updateStateIfPropsChange = this.updateStateIfPropsChange.bind(this)\n    props.onChange(this.state)\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.updateStateIfPropsChange(prevProps)\n    if (!isEqual(prevState, this.state)) {\n      const { onChange } = this.props\n      onChange(this.state)\n    }\n  }\n\n  updateStateIfPropsChange(prevProps) {\n    if (!isEqual(prevProps, this.props)) {\n      const newState = getDefaultState(this.props)\n      this.setState(newState)\n    }\n  }\n\n  /**\n   * @values an array or a string representing the values that need validations\n   * @validators an array of validators or an object with type and params or a custom funtion\n   */\n  validateInput = (values, validators, prevState, name, fieldname) => {\n    if (!validators || (Array.isArray(validators) && !validators.length))\n      return prevState.errors\n    return {\n      ...prevState.errors,\n      [name]: runValidation(values, validators, fieldname)\n    }\n  }\n\n  handleInputChange = (e, { name, value, validators, fieldname }) =>\n    this.setState((prevState) => ({\n      formData: { ...prevState.formData, [name]: value },\n      errors: this.validateInput(value, validators, prevState, name, fieldname)\n    }))\n\n  handleCheckChange = (e, { name, value, checked, validators, fieldname }) =>\n    this.setState((prevState) => {\n      const currValue = { ...prevState.formData[name].value, [value]: checked }\n      const selected = convertToArray(currValue)\n      return {\n        formData: {\n          ...prevState.formData,\n          [name]: {\n            value: currValue,\n            selected\n          }\n        },\n        errors: this.validateInput(\n          (selected || []).filter((s) => !!s),\n          validators,\n          prevState,\n          name,\n          fieldname\n        )\n      }\n    })\n\n  handleDropdownChange = (\n    e,\n    { name, value, validators, multiple, options, fieldname }\n  ) => {\n    let selectedOptions\n    let values\n    if (multiple) {\n      selectedOptions = options.filter((o) => value.includes(o.value))\n      values = selectedOptions.map((so) => so && so.text)\n    } else {\n      // eslint-disable-next-line prefer-destructuring\n      selectedOptions = options.filter((o) => o.value === value)[0]\n      values = selectedOptions && selectedOptions.text\n    }\n    this.setState((prevState) => ({\n      formData: {\n        ...prevState.formData,\n        [name]: { value, selected: selectedOptions }\n      },\n      errors: this.validateInput(values, validators, prevState, name, fieldname)\n    }))\n  }\n\n  addNewDropdownItem = (\n    e,\n    { name, value, multiple, validators, fieldname }\n  ) => {\n    if (multiple) {\n      throw new Error(\n        'Adding new elements with multiple dropdown not supported yet'\n      )\n    }\n    const { dynamicOptions } = this.state\n    const currentOption = { text: value, value: -1 }\n    dynamicOptions[name].options = [\n      ...dynamicOptions[name].options,\n      currentOption\n    ]\n\n    this.setState((prevState) => ({\n      formData: {\n        ...prevState.formData,\n        [name]: { value: currentOption.value, selected: currentOption }\n      },\n      errors: this.validateInput(value, validators, prevState, name, fieldname),\n      dynamicOptions\n    }))\n  }\n\n  async handleDynamicSearchChange(e, { name, multiple, searchQuery }) {\n    if (!searchQuery.length) return\n    const { dynamicOptions, formData } = this.state\n    dynamicOptions[name].loading = true\n    this.setState({ dynamicOptions })\n    let newOptions\n    try {\n      newOptions = await dynamicOptions[name].callback(searchQuery)\n    } catch {\n      newOptions = []\n    }\n    const oldOptions = formData[name].selected || []\n    if (multiple) {\n      dynamicOptions[name].options = uniqBy(\n        [...newOptions, ...oldOptions],\n        'value'\n      )\n    } else {\n      dynamicOptions[name].options = newOptions\n    }\n    dynamicOptions[name].loading = false\n    this.setState({ dynamicOptions })\n  }\n\n  getFormUnit(val) {\n    const { formData, errors, dynamicOptions } = this.state\n\n    if (val.type === 'hidden' || (val.config && val.config.visible === false)) {\n      return null\n    }\n    if (val.type === 'input') {\n      return (\n        <Form.Input\n          key={val.dataId}\n          required={isRequired(val.validators)}\n          validators={val.validators}\n          name={val.dataId}\n          field_name={val.fieldname}\n          label={val.fieldname}\n          value={formData[val.dataId] || ''}\n          error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          onChange={this.handleInputChange}\n          disabled={val.config && val.config.disabled}\n          {...((val.config && val.config.props) || {})}\n          data-testid='input'\n        />\n      )\n    }\n    if (val.type === 'dropdown') {\n      if (val.config && val.config.search) {\n        const isMultiple = val.config && val.config.multiple\n        let value = (formData[val.dataId] || {}).value\n        if (!value && isMultiple) {\n          // handling case for multiple dropdowns\n          value = []\n        }\n        return (\n          <Form.Dropdown\n            key={val.dataId}\n            label={val.fieldname}\n            name={val.dataId}\n            fieldname={val.fieldname}\n            options={dynamicOptions[val.dataId].options}\n            multiple={isMultiple}\n            clearable={val.config && val.config.clearable}\n            selection\n            search\n            placeholder={val.placeholder}\n            value={value}\n            onChange={this.handleDropdownChange}\n            onSearchChange={this.handleDynamicSearchChange}\n            disabled={\n              (val.config && val.config.disabled) ||\n              dynamicOptions[val.dataId].loading\n            }\n            loading={dynamicOptions[val.dataId].loading}\n            onAddItem={this.addNewDropdownItem}\n            allowAdditions={val.config && val.config.allowAdditions}\n            validators={val.validators}\n            error={!!(errors[val.dataId] && errors[val.dataId].length)}\n            required={isRequired(val.validators)}\n            data-testid='dropdown-search'\n          />\n        )\n      }\n      return (\n        <Form.Dropdown\n          key={val.dataId}\n          label={val.fieldname}\n          name={val.dataId}\n          fieldname={val.fieldname}\n          options={val.options}\n          multiple={val.config && val.config.multiple}\n          clearable={val.config && val.config.clearable}\n          selection\n          placeholder={val.placeholder}\n          value={(formData[val.dataId] || {}).value}\n          onChange={this.handleDropdownChange}\n          disabled={val.config && val.config.disabled}\n          onAddItem={this.addNewDropdownItem}\n          allowAdditions={val.config && val.config.allowAdditions}\n          loading={val.config && val.config.loading}\n          validators={val.validators}\n          error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          required={isRequired(val.validators)}\n          data-testid='dropdown'\n        />\n      )\n    }\n    if (val.type === 'radio') {\n      return (\n        <React.Fragment key={val.dataId}>\n          <Form.Field\n            required={isRequired(val.validators)}\n            error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          >\n            <label>{val.fieldname}</label>\n          </Form.Field>\n          {val.options.map((radio) => (\n            <Form.Radio\n              key={radio.value}\n              label={radio.text}\n              name={val.dataId}\n              fieldname={val.fieldname}\n              value={radio.value}\n              checked={formData[val.dataId] === radio.value}\n              onChange={this.handleInputChange}\n              validators={val.validators}\n              error={!!(errors[val.dataId] && errors[val.dataId].length)}\n            />\n          ))}\n        </React.Fragment>\n      )\n    }\n    if (val.type === 'checkbox') {\n      return (\n        <React.Fragment key={val.dataId}>\n          <Form.Field\n            required={isRequired(val.validators)}\n            error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          >\n            <label>{val.fieldname}</label>\n          </Form.Field>\n          {val.options.map((check) => (\n            <Form.Checkbox\n              key={check.value}\n              label={check.text}\n              name={val.dataId}\n              fieldname={val.fieldname}\n              value={check.value}\n              checked={\n                !!((formData[val.dataId] || {}).value || {})[check.value]\n              }\n              onChange={this.handleCheckChange}\n              validators={val.validators}\n              error={!!(errors[val.dataId] && errors[val.dataId].length)}\n            />\n          ))}\n        </React.Fragment>\n      )\n    }\n    if (val.type === 'textarea') {\n      return (\n        <Form.TextArea\n          key={val.dataId}\n          required={isRequired(val.validators)}\n          name={val.dataId}\n          fieldname={val.fieldname}\n          label={val.fieldname}\n          value={formData[val.dataId] || ''}\n          error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          onChange={this.handleInputChange}\n          validators={val.validators}\n        />\n      )\n    }\n    if (val.type === 'date') {\n      return (\n        <React.Fragment key={val.dataId}>\n          <Form.Field\n            required={isRequired(val.validators)}\n            error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          >\n            <label>{val.fieldname}</label>\n            <DatePicker\n              data-testid='date'\n              key={val.dataId}\n              name={val.dataId}\n              fieldname={val.fieldname}\n              value={formData[val.dataId]}\n              onDateChange={this.handleInputChange}\n              validators={val.validators}\n              {...((val.config && val.config.props) || {})}\n            />\n          </Form.Field>\n        </React.Fragment>\n      )\n    }\n    return <div>Improper Config</div>\n  }\n\n  validateForm = async () => {\n    const { errors: currentErrors, formData: formState } = this.state\n    const { data: form } = this.props\n    // If error exists return\n    if (Object.values(currentErrors).some((s) => s.length)) return true\n    const validatorMap = getValidatorMap(form, formState)\n    const errors = {}\n    validatorMap.forEach((vm) => {\n      if (vm.validators) {\n        errors[vm.id] = runValidation(vm.value, vm.validators, vm.name)\n      }\n    })\n    // We want to set the state first before making the final return of the function\n    return new Promise((resolve) => {\n      this.setState({ errors }, () => {\n        const hasError = !!Object.values(errors).some((s) => s.length)\n        resolve(hasError)\n      })\n    })\n  }\n\n  renderGrid(data, columns) {\n    const gridList = getFormGridStruct(data, columns)\n    const firstRowLength = (gridList[0] || []).length\n    const actualColumns = columns < firstRowLength ? columns : firstRowLength\n    return (\n      <Grid columns={actualColumns} divided padded>\n        {gridList.map((gl, idx) => (\n          <Grid.Row key={`${gl.dataId}${idx}`}>\n            {gl.map((gr, idx) => (\n              <Grid.Column key={`${gr.dataId}${idx}`}>\n                {this.getFormUnit(gr)}\n              </Grid.Column>\n            ))}\n          </Grid.Row>\n        ))}\n      </Grid>\n    )\n  }\n\n  render() {\n    const { errors } = this.state\n    const { data, loading, columns } = this.props\n\n    const isColumnView = columns > 1\n\n    return (\n      <Form\n        loading={!!loading}\n        error={errors && Object.values(errors).some((s) => s.length)}\n      >\n        <Message\n          error\n          header='Please check the form for the following'\n          list={getErrorList(errors)}\n        />\n        {isColumnView\n          ? this.renderGrid(data, columns)\n          : data.map((val) => this.getFormUnit(val))}\n      </Form>\n    )\n  }\n}\n\nFormDisplay.propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      dataId: PropTypes.string.isRequired,\n      type: PropTypes.oneOf([\n        'hidden',\n        'date',\n        'input',\n        'textarea',\n        'dropdown',\n        'checkbox',\n        'radio'\n      ]).isRequired,\n      fieldname: PropTypes.string,\n      defaultValue: PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.number,\n        PropTypes.object\n      ]),\n      config: PropTypes.object,\n      options: PropTypes.arrayOf(\n        PropTypes.shape({\n          text: PropTypes.string,\n          value: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n        })\n      ),\n      validators: PropTypes.arrayOf(\n        PropTypes.oneOfType([PropTypes.object, PropTypes.func])\n      )\n    })\n  ).isRequired,\n  onChange: PropTypes.func.isRequired,\n  loading: PropTypes.bool,\n  columns: PropTypes.number,\n  errors: PropTypes.object\n}\n","import React from 'react'\nimport { isEqual } from 'lodash'\nimport PropTypes from 'prop-types'\n\nimport FormDisplay from './FormDisplay'\nimport { getDefaultValues } from '../utils'\n\n/**\n * GenericConditionalForm component renders a form which can be conditional on the current data\n * @props (onChange): OPTIONAL: Function called whenever a formState changes\n * @props (data): the form whose format is very specfic: FormType\n * @props (defaultValues): OPTIONAL: To set the initial values of the form\n * @props (errors): OPTIONAL: To set the initial errors of the form\n * type FormType = (defaultValues: DefaultValues) => {\n *    title: String\n *    data: Array<FormUnit>\n * }\n *\n * type DefaultValues = {[ dataId: String]: { defaultValue: String | { value: Array | String, selected: Array<Textvaluepair> | TextValuePair }, options?: Array<TextValuePair> }}\n * type FormUnit = {\n *    fieldname: String,\n *    dataId: String,\n *    type: 'input' | 'checkbox' | 'dropdown' | 'radio' | 'files' | 'hidden' | 'textarea' | 'date' | 'paymentTerms',\n *    config: Object<any>,\n *    defaultValue: DefaultValue,\n *    validation?: String,\n *    options?: Array<TextValuePair>,\n * }\n * Send the form as a function which only accepts defaultValue object and fill out the rest\n */\n\nexport class Form extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      defaultValues: props.defaultValues || {},\n      prevValues: {},\n      errors: props.errors || {},\n      loading: false\n    }\n    this.formRef = React.createRef()\n    this.onChange = this.onChange.bind(this)\n    this.updateForm = this.updateForm.bind(this)\n    this.validateForm = this.validateForm.bind(this)\n  }\n\n  async onChange({ formData, errors }) {\n    const {\n      defaultValues,\n      formData: oldFormData,\n      errors: oldErrors\n    } = this.state\n    if (isEqual(oldFormData, formData) && isEqual(errors, oldErrors)) return\n    const { data: form, reSyncValues } = this.props\n    const prevForm = form(defaultValues)\n    let newDefaultValues = getDefaultValues(prevForm, formData)\n    let finalErrors = errors\n    let loading = false\n    if (reSyncValues) {\n      try {\n        loading = true\n        this.updateForm(\n          newDefaultValues,\n          defaultValues,\n          finalErrors,\n          formData,\n          loading\n        )\n        const { values, errors: newErrors } = await reSyncValues(\n          newDefaultValues,\n          defaultValues,\n          errors,\n          formData,\n          this.updateForm\n        )\n        loading = false\n        newDefaultValues = values\n        finalErrors = newErrors\n      } catch (e) {\n        loading = false\n        finalErrors.generic = true\n      }\n    }\n\n    this.updateForm(\n      newDefaultValues,\n      defaultValues,\n      finalErrors,\n      formData,\n      loading\n    )\n  }\n\n  validateForm() {\n    return this.formRef.current.validateForm()\n  }\n\n  updateForm(defaultValues, prevValues, errors, formData, loading) {\n    const { onChange } = this.props\n\n    this.setState({\n      defaultValues,\n      prevValues,\n      errors,\n      formData,\n      loading\n    })\n    if (onChange) {\n      onChange({ formData, errors })\n    }\n  }\n\n  render() {\n    const { errors, defaultValues, prevValues, loading } = this.state\n    const { data: form, columns } = this.props\n    const currentForm = form(defaultValues, prevValues)\n\n    return (\n      <FormDisplay\n        columns={columns}\n        data={currentForm}\n        onChange={this.onChange}\n        errors={errors}\n        loading={loading}\n        ref={this.formRef}\n      />\n    )\n  }\n}\n\nForm.propTypes = {\n  data: PropTypes.func,\n  errors: PropTypes.object,\n  defaultValues: PropTypes.object,\n  onChange: PropTypes.func\n}\n","import { BaseFormConfig } from 'react-generic-form';\r\n\r\nexport class ExampleBasicForm extends BaseFormConfig {\r\n  title = 'Basic Example'\r\n\r\n  data = (currValue, prevValues) => {\r\n    const { checkboxOptions, radioOptions } = this.props;\r\n    return [\r\n      {\r\n        dataId: 'id',\r\n        type: 'hidden',\r\n        defaultValue: null,\r\n      },\r\n      {\r\n        fieldname: 'Date',\r\n        dataId: 'date',\r\n        type: 'date',\r\n        defaultValue: currValue.date && currValue.date.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Name',\r\n        dataId: 'name',\r\n        type: 'input',\r\n        defaultValue: currValue.name && currValue.name.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'TextArea',\r\n        dataId: 'textarea',\r\n        type: 'textarea',\r\n        defaultValue: currValue.textarea && currValue.textarea.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Dropdown',\r\n        dataId: 'dropdown',\r\n        type: 'dropdown',\r\n        defaultValue: currValue.dropdown && currValue.dropdown.defaultValue,\r\n        config: {\r\n          clearable: true,\r\n        },\r\n        options: [\r\n          { text: 'Option1', value: 1 },\r\n          { text: 'Option2', value: 2 },\r\n        ],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Checkbox',\r\n        dataId: 'checkbox',\r\n        type: 'checkbox',\r\n        defaultValue: currValue.checkbox && currValue.checkbox.defaultValue,\r\n        options: checkboxOptions,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Radio',\r\n        dataId: 'radio',\r\n        type: 'radio',\r\n        defaultValue: currValue.radio && currValue.radio.defaultValue,\r\n        options: radioOptions,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n    ];\r\n  }\r\n}\r\n","import { BaseFormConfig } from 'react-generic-form';\r\n\r\nconst searchFunction = async () => new Promise((resolve) => setTimeout(() => resolve([\r\n  { text: 'Option1', value: 1 },\r\n  { text: 'Option2', value: 2 },\r\n  { text: 'Option3', value: 3 },\r\n  { text: 'Option4', value: 4 },\r\n]), 1000));\r\n\r\nexport class AsyncSearchExample extends BaseFormConfig {\r\n  title = 'Basic Example'\r\n\r\n  data = (currValue, prevValues) => {\r\n    return [\r\n      {\r\n        dataId: 'id',\r\n        type: 'hidden',\r\n        defaultValue: null,\r\n      },\r\n      {\r\n        fieldname: 'Date',\r\n        dataId: 'date',\r\n        type: 'date',\r\n        defaultValue: currValue.date && currValue.date.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Name',\r\n        dataId: 'name',\r\n        type: 'input',\r\n        defaultValue: currValue.name && currValue.name.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'TextArea',\r\n        dataId: 'textarea',\r\n        type: 'textarea',\r\n        defaultValue: currValue.textarea && currValue.textarea.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Dropdown',\r\n        dataId: 'dropdown',\r\n        type: 'dropdown',\r\n        defaultValue: currValue.dropdown && currValue.dropdown.defaultValue,\r\n        config: {\r\n          search: true,\r\n          callback: searchFunction,\r\n          clearable: true,\r\n        },\r\n        options: (currValue.dropdown && currValue.dropdown.options) || [],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Dropdown Multiple',\r\n        dataId: 'dropdownMul',\r\n        type: 'dropdown',\r\n        defaultValue: currValue.dropdown && currValue.dropdownMul.defaultValue,\r\n        config: {\r\n          multiple: true,\r\n          search: true,\r\n          callback: searchFunction,\r\n          clearable: true,\r\n        },\r\n        options: (currValue.dropdown && currValue.dropdownMul.options) || [],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Checkbox',\r\n        dataId: 'checkbox',\r\n        type: 'checkbox',\r\n        defaultValue: currValue.checkbox && currValue.checkbox.defaultValue,\r\n        options: [\r\n          { text: 'Checkbox1', value: 1 },\r\n          { text: 'Checkbox2', value: 2 },\r\n        ],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Radio',\r\n        dataId: 'radio',\r\n        type: 'radio',\r\n        defaultValue: currValue.radio && currValue.radio.defaultValue,\r\n        options: [\r\n          { text: 'Radio1', value: 1 },\r\n          { text: 'Radio2', value: 2 },\r\n          { text: 'Radio3', value: 3 },\r\n        ],\r\n      },\r\n    ];\r\n  }\r\n}\r\n","import { BaseFormConfig } from 'react-generic-form';\r\n\r\nconst searchFunction = async () => new Promise((resolve) => setTimeout(() => resolve([\r\n  { text: 'Option1', value: 1 },\r\n  { text: 'Option2', value: 2 },\r\n  { text: 'Option3', value: 3 },\r\n  { text: 'Option4', value: 4 },\r\n]), 1000));\r\n\r\nexport class ConditionalFormBasic extends BaseFormConfig {\r\n  title = 'Basic Example'\r\n\r\n  data = (currValue, prevValues) => {\r\n    const dateDefaultValue = currValue.date && currValue.date.defaultValue;\r\n    const nameDefaultValue = dateDefaultValue ? currValue.name && currValue.name.defaultValue : null;\r\n    const textAreaDefaultValue = nameDefaultValue ? currValue.textarea && currValue.textarea.defaultValue : null;\r\n    const dropdownDefaultValue = textAreaDefaultValue ? currValue.dropdown && currValue.dropdown.defaultValue : {};\r\n    const prevDropdownDefaultValue = prevValues && prevValues.dropdown && prevValues.dropdown.defaultValue;\r\n    const checkboxDefaultValue =(prevDropdownDefaultValue || {}).value !== (dropdownDefaultValue || {}).value\r\n      ? {}\r\n      : (currValue.checkbox && currValue.checkbox.defaultValue) || {};\r\n    const radioDefaultValue = checkboxDefaultValue.value ? currValue.radio && currValue.radio.defaultValue : {};\r\n\r\n    return [\r\n      {\r\n        dataId: 'id',\r\n        type: 'hidden',\r\n        defaultValue: null,\r\n      },\r\n      {\r\n        fieldname: 'Date',\r\n        dataId: 'date',\r\n        type: 'date',\r\n        defaultValue: dateDefaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Name',\r\n        dataId: 'name',\r\n        type: 'input',\r\n        defaultValue: nameDefaultValue,\r\n        config: {\r\n          visible: !!dateDefaultValue,\r\n        },\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'TextArea',\r\n        dataId: 'textarea',\r\n        type: 'textarea',\r\n        config: {\r\n          visible: !!nameDefaultValue,\r\n        },\r\n        defaultValue: textAreaDefaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Dropdown',\r\n        dataId: 'dropdown',\r\n        type: 'dropdown',\r\n        defaultValue: dropdownDefaultValue,\r\n        config: {\r\n          search: true,\r\n          callback: searchFunction,\r\n          clearable: true,\r\n          visible: !!textAreaDefaultValue,\r\n        },\r\n        options: (currValue.dropdown && currValue.dropdown.options) || [],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Checkbox',\r\n        dataId: 'checkbox',\r\n        type: 'checkbox',\r\n        defaultValue: checkboxDefaultValue,\r\n        config: {\r\n          visible: !!dropdownDefaultValue.value,\r\n        },\r\n        options: [\r\n          { text: 'Checkbox1', value: 1 },\r\n          { text: 'Checkbox2', value: 2 },\r\n        ],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Radio',\r\n        dataId: 'radio',\r\n        type: 'radio',\r\n        config: {\r\n          visible: checkboxDefaultValue.selected !== undefined && checkboxDefaultValue.selected !== null && !!checkboxDefaultValue.selected.length,\r\n        },\r\n        defaultValue: radioDefaultValue,\r\n        options: [\r\n          { text: 'Radio1', value: 1 },\r\n          { text: 'Radio2', value: 2 },\r\n          { text: 'Radio3', value: 3 },\r\n        ],\r\n      },\r\n    ];\r\n  }\r\n}\r\n","import { BaseFormConfig } from 'react-generic-form';\r\n\r\nconst searchFunction = async () => new Promise((resolve) => setTimeout(() => resolve([\r\n  { text: 'Option1', value: 1 },\r\n  { text: 'Option2', value: 2 },\r\n  { text: 'Option3', value: 3 },\r\n  { text: 'Option4', value: 4 },\r\n]), 1000));\r\n\r\nexport class ConditionalFormAdvanced extends BaseFormConfig {\r\n  title = 'Basic Example'\r\n\r\n  data = (currValue, prevValues) => {\r\n    return [\r\n      {\r\n        dataId: 'id',\r\n        type: 'hidden',\r\n        defaultValue: null,\r\n      },\r\n      {\r\n        fieldname: 'Date',\r\n        dataId: 'date',\r\n        type: 'date',\r\n        defaultValue: currValue.date && currValue.date.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Name',\r\n        dataId: 'name',\r\n        type: 'input',\r\n        defaultValue: currValue.name && currValue.name.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'TextArea',\r\n        dataId: 'textarea',\r\n        type: 'textarea',\r\n        defaultValue: currValue.textarea && currValue.textarea.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Dropdown',\r\n        dataId: 'dropdown',\r\n        type: 'dropdown',\r\n        defaultValue: currValue.dropdown && currValue.dropdown.defaultValue,\r\n        config: {\r\n          search: true,\r\n          callback: searchFunction,\r\n          clearable: true,\r\n        },\r\n        options: (currValue.dropdown && currValue.dropdown.options) || [],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Dropdown Multiple',\r\n        dataId: 'dropdownMul',\r\n        type: 'dropdown',\r\n        defaultValue: currValue.dropdown && currValue.dropdownMul.defaultValue,\r\n        config: {\r\n          multiple: true,\r\n          clearable: true,\r\n        },\r\n        options: (currValue.dropdown && currValue.dropdownMul.options) || [],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Checkbox',\r\n        dataId: 'checkbox',\r\n        type: 'checkbox',\r\n        defaultValue: currValue.checkbox && currValue.checkbox.defaultValue,\r\n        options: [\r\n          { text: 'Checkbox1', value: 1 },\r\n          { text: 'Checkbox2', value: 2 },\r\n        ],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldname: 'Radio',\r\n        dataId: 'radio',\r\n        type: 'radio',\r\n        defaultValue: currValue.radio && currValue.radio.defaultValue,\r\n        options: [\r\n          { text: 'Radio1', value: 1 },\r\n          { text: 'Radio2', value: 2 },\r\n          { text: 'Radio3', value: 3 },\r\n        ],\r\n      },\r\n    ];\r\n  }\r\n\r\n  reSyncValues = async (currValues, prevValues, errors) => {\r\n    const values = { ...currValues };\r\n    const currDropdownValue = currValues.dropdown && currValues.dropdown.defaultValue && currValues.dropdown.defaultValue.value;\r\n    const prevDropdownValue = prevValues.dropdown && prevValues.dropdown.defaultValue && prevValues.dropdown.defaultValue.value;\r\n\r\n    if (currDropdownValue !== prevDropdownValue) {\r\n      const options = await searchFunction();\r\n      const firstChoice = options[0];\r\n      values.dropdownMul = {\r\n        defaultValue: { value: firstChoice.value, selected: firstChoice },\r\n        options,\r\n      }\r\n    }\r\n\r\n    return ({\r\n      values,\r\n      errors,\r\n    });\r\n  }\r\n}\r\n","import React, { useState, useRef } from 'react';\r\nimport { Form } from 'react-generic-form';\r\n\r\nimport { ExampleBasicForm } from './FormConfig';\r\nimport { AsyncSearchExample } from './AsyncSearchExample';\r\nimport { ConditionalFormBasic } from './ConditionalFormBasic';\r\nimport { ConditionalFormAdvanced } from './ConditionalFormAdvanced';\r\n\r\nimport './index.css';\r\nimport 'react-generic-form/dist/index.css';\r\nimport 'semantic-ui-css/semantic.min.css';\r\n\r\nconst style = {\r\n  container: {\r\n    display: 'flex',\r\n    justifyContent: 'center',\r\n    marginTop: '16px',\r\n  },\r\n  formContainer: {\r\n    width: '400px',\r\n  },\r\n  link: {\r\n    marginRight: '8px',\r\n    cursor: 'pointer',\r\n  },\r\n  get linkSelected() {\r\n    return ({\r\n      ...this.link,\r\n      color: 'black',\r\n      fontWeight: 600,\r\n    });\r\n  },\r\n  buttonReset: {\r\n    marginLeft: '260px',\r\n    marginTop: '20px',\r\n  },\r\n  buttonSubmit: {\r\n    marginLeft: '10px',\r\n    marginTop: '20px',\r\n  },\r\n  separator: {\r\n    marginRight: '8px',\r\n  }\r\n};\r\n\r\nconst headerMap = {\r\n  basic: {\r\n    header: 'Basic Form Example',\r\n    description: 'This is a basic form example with validation.'\r\n  },\r\n  async: {\r\n    header: 'Dropdown with Asynchronous Values',\r\n    description: 'The dropdown options are loaded dynamically from backend'\r\n  },\r\n  conditional1: {\r\n    header: 'Conditional Form Basic',\r\n    description: 'The form is loaded conditionally based on the current state of the form',\r\n  },\r\n  conditional2: {\r\n    header: 'Conditional Form Advanced',\r\n    description: 'The form options to the second dropdown is based on an api call from the first dropdown',\r\n  },\r\n};\r\n\r\nconst radioOptions = [\r\n  { text: 'Radio1', value: 1 },\r\n  { text: 'Radio2', value: 2 },\r\n  { text: 'Radio3', value: 3 },\r\n];\r\n\r\nconst checkboxOptions = [\r\n  { text: 'Checkbox1', value: 1 },\r\n  { text: 'Checkbox2', value: 2 },\r\n];\r\n\r\nexport default () => {\r\n  const formRef = useRef(null);\r\n  const [ formType, setFormType ] = useState('basic');\r\n  const [ defaultValues, setDefaultValues ] = useState({});\r\n\r\n  const exampleForm = new ExampleBasicForm({ radioOptions, checkboxOptions });\r\n  const asyncExample = new AsyncSearchExample();\r\n  const conditionalFormBasic = new ConditionalFormBasic();\r\n  const conditionalFormAdvanced = new ConditionalFormAdvanced();\r\n\r\n  const validateForm = () => {\r\n    if (formRef.current.validateForm) {\r\n      formRef.current.validateForm();\r\n    }\r\n  };\r\n\r\n  const resetForm = () => setDefaultValues({});\r\n  \r\n  const getLinkStyle = (linkName) => linkName === formType ? style.linkSelected : style.link;\r\n\r\n  return (\r\n    <div style={style.container}>\r\n      <div style={style.formContainer}>\r\n        <div>\r\n          <button\r\n            onClick={() => setFormType('basic')}\r\n            style={getLinkStyle('basic')}\r\n            className={'link'}\r\n          >\r\n            Basic\r\n          </button>\r\n          <span style={style.separator}>|</span> \r\n          <button\r\n            onClick={() => setFormType('async')}\r\n            style={getLinkStyle('async')}\r\n            className={'link'}\r\n          > \r\n          Async\r\n          </button>\r\n          <span style={style.separator}>|</span> \r\n          <button\r\n            onClick={() => setFormType('conditional1')}\r\n            style={getLinkStyle('conditional1')}\r\n            className={'link'}\r\n          >\r\n            Conditional\r\n          </button>\r\n          <span style={style.separator}>|</span> \r\n          <button\r\n            onClick={() => setFormType('conditional2')}\r\n            style={getLinkStyle('conditional2')}\r\n            className={'link'}\r\n          >\r\n            Conditional (Adv)\r\n          </button>\r\n          <span style={style.separator}>|</span> \r\n          <hr />\r\n        </div>\r\n        <div>\r\n          <h3>{headerMap[formType].header}</h3>\r\n          <span>{headerMap[formType].description}</span>\r\n        </div>\r\n        {formType === 'basic' && <Form\r\n          data={exampleForm.data}\r\n          ref={formRef}\r\n          defaultValues={defaultValues}\r\n        />}\r\n        {formType === 'async' && <Form\r\n          data={asyncExample.data}\r\n          ref={formRef}\r\n        />}\r\n        {formType === 'conditional1' && <Form\r\n          data={conditionalFormBasic.data}\r\n          ref={formRef}\r\n        />}\r\n        {formType === 'conditional2' && <Form\r\n          data={conditionalFormAdvanced.data}\r\n          reSyncValues={conditionalFormAdvanced.reSyncValues}\r\n          ref={formRef}\r\n        />}\r\n        <div>\r\n          <button onClick={resetForm} className={'btn btn_secondary'} style={style.buttonReset}>\r\n            Reset\r\n          </button>\r\n          <button onClick={validateForm} className={'btn btn_primary'} style={style.buttonSubmit}>\r\n            Submit\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n} \r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nimport './index.css';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}