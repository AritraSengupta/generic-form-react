{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/utils/ValidationUtils.js","../../src/utils/Common.js","../../src/utils/FormUtils.js","../../src/utils/BaseFormConfig.js","../../src/components/Calendar/Month.js","../../src/components/Calendar/MonthYearPicker.js","../../src/components/Calendar/DatePicker.js","../../src/components/FormDisplay.js","../../src/components/Form.js","FormConfig.js","App.js","index.js"],"names":["Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","standardValidators","required","state","value","message","maxLength","minLength","number","Number","max","min","pattern","RegExp","regPattern","validateValue","validator","Error","runValidationAgainstAllValues","values","Array","error","i","runValidation","validators","name","errors","isRequired","v","isValidDate","d","isNaN","getDateString","date","month","year","getErrorList","errorList","Object","key","valErrors","getDefaultState","props","formData","acc","curr","dynamicOptions","options","callback","loading","BaseFormConfig","this","isDisabledCell","startDisable","endDisable","start","end","currentDate","Date","MonthTable","tableBodyProps","selectedOrCurrent","cellDate","onChange","highlightedDates","disableStart","disableEnd","cells","day","isDisabled","dayObj","content","className","onClick","specialSign","getMonthData","lastDate","days","createMonthObject","getHeaderRow","_dayArray","map","style","padding","data","dayString","dayIndex","render","tableData","headerRow","size","textAlign","collapsing","renderBodyRow","React","monthData","yearData","MonthPicker","selectedMonth","_clickMonth","onSelectMonth","YearPicker","selectedYear","yearObj","_clickYear","onSelectYear","parseInt","getDateMonthYear","dateValue","providedDate","arr","changeToUSDateStyle","isValidProvidedDate","defaultDate","Changer","label","onPrev","onNext","height","backgroundColor","display","margin","cursor","DatePicker","_monthArray","onDateChange","popupOpen","showMonth","showYear","pickerYear","startDisabledObj","endDisabledObj","startDisabled","endDisabled","getDerivedStateFromProps","propsValue","nextProps","stateValue","prevState","startOld","endOld","newState","shouldComponentUpdate","popupOpenNew","nextState","isEqual","DatePickerHolder","_showYearTable","_showMonthTable","_today","YearPickerHolder","MonthPickerHolder","Picker","Trigger","fluid","icon","iconPosition","_onClick","trigger","on","open","onClose","basic","verticalOffset","Component","GenericForm","fieldName","checked","hashMap","selected","multiple","selectedOptions","o","so","currentOption","text","currentErrors","formState","form","s","validatorMap","el","id","getValidatorMap","vm","Promise","hasError","resolve","debounce","componentDidUpdate","UNSAFE_componentWillReceiveProps","handleDynamicSearchChange","searchQuery","oldOptions","uniqBy","newOptions","getFormUnit","val","Form","disabled","clearable","selection","search","placeholder","onSearchChange","onAddItem","allowAdditions","dataId","radio","check","renderGrid","gridList","columns","gridRow","j","getFormGridStruct","firstRowLength","actualColumns","divided","padded","Grid","gl","gr","isColumnView","header","list","defaultValues","prevValues","oldFormData","oldErrors","reSyncValues","newDefaultValues","defaultValue","get","getDefaultValues","finalErrors","newErrors","validateForm","formRef","current","updateForm","currentForm","ref","ExampleBasicForm","title","currValue","type","from","textarea","dropdown","config","checkbox","container","justifyContent","formContainer","width","exampleForm","ReactDOM","App","document","getElementById"],"mappings":"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","file":"static/js/main.083a698c.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * This file contains all the utils regarding the form validation process,\n * We will use the following structure for error:\n * @param error: {\n *  name: <string> 'field name',\n *  state: <boolean> 'true or false',\n *  message: <string> message to be shown to the user in case state is true\n * }\n */\n\nexport const standardValidators = {\n\n  required: (value) => ({\n    state: !(value && value.length),\n    message: 'is required',\n  }),\n  \n  maxLength: (value, { maxLength }) => {\n    if (typeof value !== 'string') {\n      return ({\n        state: true,\n        message: 'should be a string'\n      });\n    }\n    return ({\n      state: value.length > maxLength,\n      message: `can be a maximum length of ${maxLength}`,\n    });\n  },\n\n  minLength: (value, { minLength }) => {\n    if (typeof value !== 'string') {\n      return ({\n        state: true,\n        message: 'should be a string'\n      });\n    }\n    return ({\n      state: value.length < minLength,\n      message: `should be a minimum length of ${minLength}`,\n    });;\n  },\n\n  number: (value) => ({\n    state: !((typeof value === 'number') || !Number.isNaN(Number(value))),\n    message: 'should be a number',\n  }),\n\n  max: (value, { max }) => ({\n    state: Number(value) > max,\n    message: `cannot be more than ${max}`,\n  }),\n\n  min: (value, { min }) => ({\n    state: Number(value) < min,\n    message: `cannot be less than ${min}`,\n  }),\n\n  pattern: (value, { pattern, message }) => {\n    const regPattern = new RegExp(pattern);\n    return {\n      state: !regPattern.test(value),\n      message: message || `does not match pattern ${pattern}`,\n    };\n  }\n}\n\nexport const validateValue = (value, validator) => {\n  if (typeof validator === 'function') {\n    return validator(value);\n  }\n\n  if (validator.type && standardValidators[validator.type]) {\n    return standardValidators[validator.type](value, validator.params)\n  } \n  \n  throw new Error('Not a valid Validator');\n}\n\nexport const runValidationAgainstAllValues = (values, validator) => {\n  if (Array.isArray(values)) {\n    let error = null;\n    for (let i = 0; i < values.length; i += 1) {\n      if (error && error.state) break;\n      error = validateValue(values[i], validator);\n    }\n    return error;\n  }\n  return validateValue(values, validator);\n}\n\nexport const runValidation = (values, validators, name) => {\n  if (Array.isArray(validators)) {\n    const errors = [];\n    validators.forEach(validator => {\n      const error = runValidationAgainstAllValues(values, validator);\n\n      if (error.state) {\n        errors.push({name, ...error});\n      }\n    });\n    return errors;\n  }\n  const error = runValidationAgainstAllValues(values, validators);\n  return error.state ? [{name, ...error}] : [];\n}\n\nexport const isRequired = (validators) => {\n  if (Array.isArray(validators)) {\n    return validators.some(v => !!(v && v.type === 'required'));\n  }\n  return !!(validators && validators.type === 'required');\n}\n","\nexport function changeToUSDateStyle(value) {\n  const arr = value.split('-');\n  const usStyle = [arr[1], arr[0], arr[2]].join('-');\n  return usStyle;\n}\n\nexport function isValidDate(d) {\n  return d instanceof Date && !isNaN(d);\n}\n\nexport function formatInputIfDate(date) {\n  if (!date || typeof date !== 'string') return date;\n  const dateArray = date.split('-');\n  if(dateArray.length === 3 && !isValidDate(new Date(date))) {\n    // Try to format if not a valid date\n    const openApiDate = `${dateArray[2]}-${dateArray[1]}-${dateArray[0]}`;\n    const dateObj = new Date(openApiDate);\n    if (isValidDate(dateObj)) {\n      return openApiDate;\n    }\n  }\n  return date;\n} \n\nexport function getDateString(date, month, year) {\n  return `${date}-${month + 1}-${year}`\n}\n\n\nexport const getFormattedDate = (date) => {\n  if (!isValidDate(new Date(date))) return date;\n\n  const dateObj = new Date(date);\n  return getDateString(dateObj.getDate(), dateObj.getMonth(), dateObj.getFullYear());\n}\n\nexport const formatToFixed = (value, decimalPlaces, defaultValue) => {\n  const numericalValue = parseFloat(value).toFixed(decimalPlaces);\n  if (!isNaN(numericalValue)) {\n    return numericalValue;\n  }\n  return defaultValue;\n}\n\nexport const twoDecimals = (value, decimalPoints) => {\n  if (value === 0) return 0;\n  const t = value ? `${value  }` : '';\n  if (Number(t) < 0 || t === '-') {\n    return '';\n  }\n  const newValue = (t.indexOf('.') >= 0) ? (t.substr(0, t.indexOf('.')) + t.substr(t.indexOf('.'), decimalPoints + 1)) : t;\n  return newValue;\n}\n\nexport const convertToArray = (hashMap) => Object.keys(hashMap).filter(key => hashMap[key])","import { get, set, uniqBy, isPlainObject, has } from 'lodash';\n\nimport { formatInputIfDate } from './Common';\n\n/**\n * @param {*} formData -> the form datastructure object\n * @param {*} formState -> the current state of the form\n * This function returns the default values of the current form in the format which\n * the form understands. Should be used when converting formState to defaultvalue object\n * to be passed to the form\n */\n\nexport const getDefaultValues = (formData, formState) => {\n  const defaultValues = {};\n  formData.forEach(data => {\n    if (data.type === 'checkbox') {\n      const defaultValue = get(formState, data.dataId, { value: [], selected: {} });\n      defaultValues[data.dataId] = {\n        defaultValue,\n      };\n      return;\n    }\n    if (data.type === 'files') {\n      const defaultValue = get(formState, data.dataId, []);\n      defaultValues[data.dataId] = { defaultValue };\n      return;\n    }\n    if (data.type === 'dropdown' || data.type === 'paymentTerms') {\n      const defaultValue = get(formState, data.dataId, {});\n      let value;\n      let options;\n      if (data.config && data.config.multiple) {\n        value = defaultValue && defaultValue.selected || [];\n        options = uniqBy([...(data.options || []), ...value], 'value');\n      } else {\n        const { selected } = defaultValue || {};\n        value = selected ? [selected] : [];\n        options = uniqBy([...(data.options || []), ...value], 'value');\n      }\n      defaultValues[data.dataId] = {\n        defaultValue,\n        options,\n      };\n      return;\n    }\n    const defaultValue = get(formState, data.dataId, null);\n    defaultValues[data.dataId] = {\n      defaultValue,\n    };\n  });\n  return defaultValues;\n}\n\n/**\n * \n * @param {*} formDataFunc: The conditional Form Function\n * @param {*} apiData: apiData of that needs mapped\n * @param {*} dataMap: the datamap to map apidata to formdata\n * \n * returns an object with keys as form ids and value with default values from api\n * NOTE options from dropdown are not mapped\n */\nexport const conditionalFormDefaultValuesGetter = (formDataFunc, apiData, dataMap) => {\n  const formData = formDataFunc({});\n  const mappedDefaults = {};\n  formData.forEach(data => {\n    if (data.type === 'checkbox') {\n      const defaultValue = get(apiData, dataMap[data.dataId], null);\n      if (defaultValue === null || defaultValue === undefined) { // case to handle null values for api calls\n        mappedDefaults[data.dataId] = {\n          defaultValue: null,\n        };\n      } else {\n        const value = (defaultValue || []).reduce((acc, curr) => {\n          acc[curr] = true;\n          return acc;\n        }, {});\n        mappedDefaults[data.dataId] = {\n          defaultValue: {\n            value,\n            selected: defaultValue\n          },\n        };\n      }\n    } else if (data.type === 'files') {\n      const defaultValue = get(apiData, dataMap[data.dataId], []);\n      mappedDefaults[data.dataId] = {\n        defaultValue: {\n          files: defaultValue,\n          deletedFiles: [],\n        },\n      };\n    } else if (data.type === 'dropdown' || data.type === 'paymentTerms') {\n      const defaultValue = get(apiData, dataMap[data.dataId].id, null);\n      if (defaultValue === null || defaultValue === undefined) { // case to handle null api values for api calls\n        mappedDefaults[data.dataId] = {\n          defaultValue: null,\n          options: data.options,\n        };\n      } else {\n        const valueLabel = dataMap[data.dataId].value || 'id';\n        const textLabel = dataMap[data.dataId].text || 'name';\n        let value;\n        let options;\n        if (data.config && data.config.multiple) {\n          const selected = (defaultValue && defaultValue.map(d => ({\n            value: d[valueLabel],\n            text: d[textLabel],\n          }))) || [];\n          value = {value: (defaultValue && defaultValue.map(d => d[valueLabel])) || [], selected };\n          options = uniqBy([...data.options, ...selected], 'value');\n        } else {\n          const selected = { text: defaultValue && defaultValue[textLabel], value: defaultValue && defaultValue[valueLabel] };\n          value = { value: defaultValue && defaultValue[valueLabel], selected };\n          options = uniqBy([...data.options, selected], 'value');\n        }\n        mappedDefaults[data.dataId] = {\n          defaultValue: {\n            ...value,\n          },\n          options,\n        };\n      }\n    } else {\n      const defaultValue = get(apiData, dataMap[data.dataId], null);\n      mappedDefaults[data.dataId] = {\n        defaultValue\n      };\n    }\n  });\n  return mappedDefaults;\n}\n\nexport const defaultValueMapper = (formData, apiData, dataMap) =>\n  formData.map(data => {\n    if (data.type === 'checkbox') {\n      const defaultValue = get(apiData, dataMap[data.dataId], []) || [];\n      const value = defaultValue.reduce((acc, curr) => {\n        acc[curr] = true;\n        return acc;\n      }, {});\n      return ({\n        ...data,\n        defaultValue: { value, selected: defaultValue }\n      });\n    }\n    if (data.type === 'files') {\n      const defaultValue = get(apiData, dataMap[data.dataId], []);\n      return ({\n        ...data,\n        defaultValue: { files: defaultValue, deletedFiles: [] },\n      }); \n    }\n    if (data.type === 'dropdown' || data.type === 'paymentTerms') {\n      const defaultValue = get(apiData, dataMap[data.dataId].id, null);\n      const valueLabel = dataMap[data.dataId].value || 'id';\n      const textLabel = dataMap[data.dataId].text || 'name';\n      let value;\n      let options;\n      if (data.config && data.config.multiple) {\n        const selected = (defaultValue && defaultValue.map(d => ({\n          value: d[valueLabel],\n          text: d[textLabel],\n        }))) || [];\n        value = {value: (defaultValue && defaultValue.map(d => d[valueLabel])) || [], selected };\n        options = uniqBy([...(data.options || []), ...selected], 'value');\n      } else {\n        const selected = { text: defaultValue && defaultValue[textLabel], value: defaultValue && defaultValue[valueLabel] };\n        value = { value: defaultValue && defaultValue[valueLabel], selected };\n        options = uniqBy([...(data.options || []), selected], 'value');\n      }\n      return {\n        ...data,\n        defaultValue: value,\n        options,\n      }\n    }\n    const defaultValue = get(apiData, dataMap[data.dataId], null);\n    return ({\n      ...data,\n      defaultValue,\n    });\n  });\n\nexport const apiDataMapper = (formData, dataMap) => {\n  const apiData = {};\n  Object.keys(formData).forEach(key => {\n    let formDataValue;\n    // Doing it this way ensures that is the selected key is present then the value\n    // inside selected is retured regardless whether its falsy or not\n    if (has(formData, `${key}.selected`)) {\n      formDataValue = formData[key].selected;\n    } else if (has(formData, `${key}.files`)) {\n      formDataValue = formData[key].files;\n    } else {\n      // Change to OpenAPI spec if the date is in DD-MM-YYYY format\n      formDataValue = formatInputIfDate(formData[key]);\n    }\n    const formKey = dataMap[key].id || dataMap[key];\n    set(apiData, formKey, formDataValue);\n  });\n  return apiData;\n};\n\nexport const dropdownOptionsMapper = (list, valueLabel = 'id', textLabel = 'name') => {\n  if (!list) return [];\n  return list.map(l => ({\n    text: l[textLabel],\n    value: l[valueLabel],\n  }));\n};\n\nexport const removeNullFilters = (filtersCopy) => {\n  const filters = {...filtersCopy};\n  Object.keys(filters).forEach(f => {\n    if(filters[f] || filters[f] === 0 || filters[f] === false || filters[f] === '0') {\n      if (isPlainObject(filters[f])) {\n        if(filters[f].value !== 0 && (!filters[f].value || (Array.isArray(filters[f].value) && filters[f].value.length === 0))) {\n          delete filters[f];\n        } else {\n          filters[f] = filters[f].value;\n        }\n      } else if (Array.isArray(filters[f])) {\n        if (!filters[f].length) {\n          delete filters[f];\n        } else {\n          filters[f] = filters[f].map(fil => fil.value);\n        }\n      }\n    } else {\n      delete filters[f];\n    }\n  });\n  return filters;\n};\n\nexport const getValidatorMap = (form, formState) => form.map(el => {\n    let value = formState[el.dataId];\n    if (value && el.type === 'dropdown') {\n      const { selected } = value;\n      if (Array.isArray(selected)) {\n        value = selected.map(s => s.text);\n      } else {\n        value = selected && selected.text;\n      }\n    };\n    return {\n      id: el.dataId,\n      validators: el.validators,\n      value,\n      name: el.fieldName,\n    }\n  });\n\n/**\n  Extracts filters data from fully formed Generic Form DataCue\n  @param {*} formData fully formed form data with default values\n  returns an array of type Array<{name: string, value: string}>\n*/\nexport const extractFilterLabels = (filtersMap = [], returnAllFilters = false) => {\n  if (Array.isArray(filtersMap) && filtersMap.length) {\n    return filtersMap.reduce((final, curr) => {\n      const {defaultValue, fieldName} = curr;\n      if (defaultValue && defaultValue.selected) {\n        if (Array.isArray(defaultValue.selected) && (defaultValue.selected.length || returnAllFilters)) {\n          final.push({name: fieldName, value: (defaultValue.selected.filter(s => !!s.text) || []).map(s => s.text).join(', ')});\n        } else if (defaultValue.selected.text || returnAllFilters) {\n          final.push({name: fieldName, value: (defaultValue.selected || {}).text });\n        }\n      } else if (defaultValue || returnAllFilters) {\n        final.push({name: fieldName, value: defaultValue })\n      }\n      return final;\n    }, []);\n  }\n\n  return [];\n}\n\nexport const getFormGridStruct = (formData, columns) => {\n  const gridList = [];\n  let i = 0;\n  while (i < formData.length) {\n    const gridRow = [];\n    let j = 0;\n    while(j < columns && i < formData.length) {\n      if (formData[i] && formData[i].type !== 'hidden') {\n        gridRow.push(formData[i]);\n        j += 1;\n      }\n      i += 1;\n    }\n\n    if (gridRow.length) {\n      gridList.push(gridRow);\n    }\n  }\n  return gridList;\n}\n\nexport const getErrorList = (errors) => {\n  const errorList = [];\n  Object.keys(errors).forEach(key => {\n    const valErrors = [];\n    (errors[key] || []).forEach(e => {\n      e.state && valErrors.push(`${e.name}: ${e.message}`);\n    });\n    errorList.push(...valErrors);\n  });\n  return errorList;\n}\n\n\nexport function getDefaultState(props) {\n  return {\n    formData: props.data.reduce((acc, curr) => {\n      acc[curr.dataId] = curr.defaultValue;\n      return acc;\n    }, {}),\n    errors: props.errors || {},\n    dynamicOptions: props.data.reduce((acc, curr) => {\n      if (curr.type === 'dropdown' && curr.config && curr.config.search) {\n        acc[curr.dataId] = {\n          options: curr.options,\n          callback: curr.config.callback,\n          loading: false,\n        };\n      }\n      return acc;\n    }, {})\n  };\n}","export default class BaseFormConfig {\n  constructor(props) {\n    this.props = props;\n  }\n\n  title = 'Generic Conditional Input Form';\n\n  data = () => ([])\n\n  reSyncValues = async (values, prevValues, errors) => ({ values, errors })\n}","import React from 'react'\nimport { Table } from 'semantic-ui-react';\nimport { getDateString, isValidDate } from '../../utils';\n\nexport const isDisabledCell = (date, month, year, startDisable, endDisable) => {\n  if (!date) return true;\n\n  if (!isValidDate(startDisable)  && !isValidDate(endDisable)) return false;\n  const start = isValidDate(startDisable) ? startDisable : -Infinity;\n  const end = isValidDate(endDisable) ? endDisable : Infinity;\n  const currentDate = new Date(year, month, date);\n\n  return (currentDate >= start) && (currentDate <= end);\n}\n\n/**\n * type Props = {\n *  onChange: (e: Event, name: string) => void\n *  month: string\n *  year: string\n *  selectedOrCurrent: Date string (DD-MM-YYYY), showing date in blue, useful for showing selection\n *  highlightedDates: Array<{[date: number]: warning | negative | positive | error}>\n * }\n * \n * selectedOrCurrent is used to show a selected or current date when using a date picker\n * highlightedDates are to be used in calendar mode when each month is a different instance of the component\n */\n\nexport class MonthTable extends React.Component {\n  _dayArray = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];\n\n  _monthArray = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  \n  getMonthData(month, year) {\n    // Month + 1 because 0th date is last day of prev month\n    const lastDate = new Date(year, month + 1, 0);\n    if (isValidDate(lastDate)) {\n      const days = lastDate.getDate();\n      const day = lastDate.getDay();\n      return this.createMonthObject([{}], day, days)\n    }\n    return null;\n  }\n\n  _getClassName = (day, tableBodyProps, disabled) => {\n    const date = tableBodyProps[day] || '';\n    if (!date) return 'compact';\n    if (disabled) return 'compact disabled';\n    const { month, year, selectedOrCurrent } = this.props;\n    const cellDate = getDateString(date, month, year);\n    return cellDate === selectedOrCurrent ? 'compact highlight selected' : 'compact highlight';\n  }\n\n  _clickDay = (e) => {\n    const { onChange } = this.props;\n    onChange(e, e.target.dataset.name);\n  }\n\n  processCells = (tableBodyProps) => {\n    const { highlightedDates, month, year, disableStart, disableEnd } = this.props;\n    const cells = [];\n    this._dayArray.forEach(day => {\n      const isDisabled = isDisabledCell(tableBodyProps[day], month, year, disableStart, disableEnd);\n      const dayObj = {\n        key: day,\n        content: tableBodyProps[day] || '',\n        className: this._getClassName(day, tableBodyProps, isDisabled),\n        onClick: !isDisabled ? this._clickDay : null, // To prevent clicking outside a given date\n        'data-name': tableBodyProps[day],\n      };\n      const specialSign = highlightedDates && highlightedDates[tableBodyProps[day]];\n      if (specialSign) {\n        dayObj[specialSign] = true;\n      }\n      cells.push(dayObj);\n    });\n    return cells;\n  }\n\n  getHeaderRow() {\n    return {\n      cells: this._dayArray.map(day => ({\n        key: day,\n        style: { padding: 0 },\n        content: day\n      })),\n    };\n  }\n    \n  createMonthObject(data, dayIndex, date) {\n    if (date === 0) return data;\n\n    const dayString = this._dayArray[dayIndex];\n    \n    // eslint-disable-next-line\n    data[0][dayString] = date;\n    \n    if (dayIndex === 0 && date > 1) {\n      data.unshift({});\n      return this.createMonthObject(data, 6, date - 1);\n    }\n    \n    return this.createMonthObject(data, dayIndex - 1, date - 1);\n  }\n\n  renderBodyRowNew = (tableBodyProps, i) => ({\n    key: `row-${i}`,\n    cells: this.processCells(tableBodyProps),\n  });\n\n  render() {\n    const { month, year } = this.props;\n    const tableData = this.getMonthData(month, year);\n    const headerRow = this.getHeaderRow();\n    if (!tableData) {\n      return <span> Invalid Date </span>\n    }\n    return (\n      <Table \n        size='small'\n        textAlign='center'\n        collapsing\n        headerRow={headerRow}\n        renderBodyRow={this.renderBodyRowNew}\n        tableData={tableData}\n        className='table-month'\n      />\n    );\n  }\n}\n\nexport default MonthTable","import React from 'react';\nimport { Table } from 'semantic-ui-react';\n\nconst monthData = [\n  ['Jan', 'Feb', 'Mar'],\n  ['Apr', 'May', 'Jun'],\n  ['Jul', 'Aug', 'Sep'],\n  ['Oct', 'Nov', 'Dec'],\n];\n\nconst yearData = (year) => ([\n  [year - 7, year - 6, year - 5],\n  [year - 4, year - 3, year - 2],\n  [year - 1, year, year + 1],\n  [year + 2, year + 3, year + 4],\n]);\n\nexport class MonthPicker extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this._clickMonth = this._clickMonth.bind(this);\n  }\n\n  processCells = (tableBodyProps) => {\n    const { selectedMonth } = this.props;\n    const cells = [];\n    tableBodyProps.forEach(month => {\n      const dayObj = {\n        key: month,\n        content: month || '',\n        className: `compact highlight ${selectedMonth === month ? 'selected' : ''}`,\n        onClick: this._clickMonth,\n        'data-name': month,\n      };\n      cells.push(dayObj);\n    });\n    return cells;\n  }\n\n  renderBodyRowNew = (tableBodyProps, i) => ({\n    key: `row-${i}`,\n    cells: this.processCells(tableBodyProps),\n  });\n\n  _clickMonth(e) {\n    const { onSelectMonth } = this.props;\n    onSelectMonth(e.target.dataset.name);\n  }\n\n  render() {\n    return (\n      <Table \n        size='small'\n        textAlign='center'\n        renderBodyRow={this.renderBodyRowNew}\n        tableData={monthData}\n        className='table-month'\n      />\n    );\n  }\n}\n\nexport class YearPicker extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this._clickYear = this._clickYear.bind(this);\n  }\n\n  _clickYear(e) {\n    const { onSelectYear } = this.props;\n    onSelectYear(parseInt(e.target.dataset.name));\n  }\n\n  processCells = (tableBodyProps) => {\n    const { selectedYear } = this.props;\n    const cells = [];\n    tableBodyProps.forEach(year => {\n      const yearObj = {\n        key: year,\n        content: year || '',\n        className: `compact highlight ${selectedYear === year ? 'selected' : ''}`,\n        onClick: this._clickYear,\n        'data-name': year,\n      };\n      cells.push(yearObj);\n    });\n    return cells;\n  }\n\n  renderBodyRowNew = (tableBodyProps, i) => ({\n    key: `row-${i}`,\n    cells: this.processCells(tableBodyProps),\n  });\n\n\n  render() {\n    const { year } = this.props;\n    return (\n      <Table \n        size='small'\n        textAlign='center'\n        renderBodyRow={this.renderBodyRowNew}\n        tableData={yearData(year)}\n        className='table-month'\n      />\n    );\n  }\n}","import React from 'react';\nimport { Input, Icon, Popup } from 'semantic-ui-react';\nimport { isEqual } from 'lodash';\n\nimport { MonthTable } from './Month';\nimport { MonthPicker, YearPicker } from './MonthYearPicker';\nimport { isValidDate, getDateString, changeToUSDateStyle } from '../../utils';\n\nimport './DatePicker.css';\n\n/**\n * \n * @param {*} dateValue date input string\n * This functions attempts to convert the input string into a valid date or else tells its an invalid date\n * However if the date is invalid it returns today's day month and year for default placement \n */\nexport const getDateMonthYear = (dateValue) => {\n  // Chaning to US style takes priority\n  let providedDate = new Date(changeToUSDateStyle(dateValue || ''));\n  let isValidProvidedDate = isValidDate(providedDate);\n  if (!isValidProvidedDate) { // Last try\n    providedDate = new Date(dateValue || '');\n    isValidProvidedDate = isValidDate(providedDate);\n  }\n  const defaultDate = isValidProvidedDate\n    ? providedDate\n    : new Date(Date.now());\n  const month = defaultDate.getMonth(); const year = defaultDate.getFullYear(); const date = defaultDate.getDate();\n\n  return {\n    isValidProvidedDate,\n    date,\n    month,\n    year,\n    value: `${date}-${month + 1}-${year}`,\n  };\n};\n\nexport const Changer = ({ label, onPrev, onNext, onClick }) => (\n  <div style={{height: 20, backgroundColor: 'white'}}>\n    <Icon name='arrow left' onClick={onPrev} className='arrow_icon'/>\n    <div style={{display: 'inline-block', margin: '0 40px', cursor: 'pointer'}} onClick={onClick}>{label}</div>\n    <Icon name='arrow right' onClick={onNext} className='arrow_icon'/>\n  </div>\n);\n\n/**\n * Props: {\n *  value(OPTIONAL): date string format (DD-MM-YYYY) to be shown on the input field, default is Date.now()\n *  onDateChange(OPTIONAL): (e: event, {props: Props, value: string}) => void\n * }\n */\nexport default class DatePicker extends React.Component {\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const {value: propsValue, startDisabled, endDisabled } = nextProps;\n    const startDisabledObj = getDateMonthYear(startDisabled || null);\n    const endDisabledObj = getDateMonthYear(endDisabled || null);\n    const {value: stateValue, startDisabled: startOld, endDisabled: endOld } = prevState;\n    const { isValidProvidedDate, value } = getDateMonthYear(propsValue);\n\n    const newState = {};\n    if ((propsValue && propsValue !== stateValue)) {\n      newState.value = isValidProvidedDate ? value : propsValue;\n    }\n\n    if (startDisabledObj.value !== startOld) {\n      newState.startDisabled = startDisabledObj.isValidProvidedDate ? startDisabledObj : null;\n    }\n\n    if (endDisabledObj.value !== endOld) {\n      newState.endDisabled = endDisabledObj.isValidProvidedDate ? endDisabledObj : null;\n    }\n\n    return newState;\n  }\n\n  _monthArray = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n  constructor(props) {\n    super(props);\n\n    const { date, month, year, isValidProvidedDate, value } = getDateMonthYear(props.value);\n    const startDisabledObj = getDateMonthYear(props.startDisabled || '');\n    const endDisabledObj = getDateMonthYear(props.endDisabled || '');\n    this.state = {\n      month,\n      year,\n      date,\n      value: isValidProvidedDate ? value : '',\n      popupOpen: false,\n      showMonth: false,\n      showYear: false,\n      pickerYear: year,\n      startDisabled: startDisabledObj.isValidProvidedDate ? startDisabledObj : null,\n      endDisabled: endDisabledObj.isValidProvidedDate ? endDisabledObj : null,\n    };\n    this._today = getDateString(date, month, year);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { value, popupOpen } = this.state;\n    const { popupOpenNew } = nextState;\n    const { value: newValue } = nextProps;\n    return value !== newValue || popupOpen !== popupOpenNew || !isEqual(this.props, nextProps);\n  }\n\n  _yearPrev = () => {\n    let { year } = this.state;\n    year -= 1;\n    this.setState({ year });\n  }\n\n  _yearNext = () => {\n    let { year } = this.state;\n    year += 1;\n    this.setState({ year });\n  }\n\n  _monthNext = () => {\n    let { month, year } = this.state;\n    month += 1;\n    if (month > 11) {\n      month = 0;\n      year += 1;\n    }\n    this.setState({ month, year });\n  }\n\n  _monthPrev = () => {\n    let { month, year } = this.state;\n    month -= 1;\n    if (month < 0) {\n      month = 11;\n      year -= 1;\n    }\n    this.setState({ month, year });\n  }\n\n  _onDateChange = (e, date) => {\n    const { month, year} = this.state;\n    const { onDateChange } = this.props;\n    const value = getDateString(date, month, year);\n    if (onDateChange) { \n      onDateChange(e, { ...this.props, value });\n      this.setState({ popupOpen: false });\n    } else {\n      this.setState({ value, date, popupOpen: false });\n    }\n  }\n\n  _onClick = () => {\n    this.setState({ popupOpen: true });\n  }\n\n  _handleClose = () => {\n    this.setState({ popupOpen: false });\n  }\n\n  _showMonthTable = () => {\n    this.setState({ showMonth: true });\n  }\n\n  _hideMonthTable = () => {\n    this.setState({ showMonth: false });\n  }\n\n  _showYearTable = () => {\n    this.setState({ showYear: true });\n  }\n\n  _onSelectMonth = (month) => {\n    this.setState({ month: this._monthArray.indexOf(month), showMonth: false });\n  }\n\n  _onSelectYear = (year) => {\n    this.setState({ year, pickerYear: year, showYear: false });\n  }\n\n _pickerYearPrev = () => {\n   const { pickerYear } = this.state;\n   this.setState({pickerYear: pickerYear - 12});\n }\n\n _pickerYearNext = () => {\n  const { pickerYear } = this.state;\n  this.setState({pickerYear: pickerYear + 12});\n}\n\n  render() {\n    const { month, year, date, value, popupOpen, showMonth, showYear, pickerYear, startDisabled, endDisabled } = this.state;\n    const disableStart = startDisabled ? new Date(startDisabled.year, startDisabled.month, startDisabled.date) : null;\n    const disableEnd = endDisabled ? new Date(endDisabled.year, endDisabled.month, endDisabled.date) : null;\n\n    const DatePickerHolder = (\n      <div className='date_picker_container results transition visible'>\n        <Changer \n          label={year}\n          onPrev={this._yearPrev}\n          onNext={this._yearNext}\n          onClick={this._showYearTable}\n        />\n        <Changer \n          label={this._monthArray[month]}\n          onPrev={this._monthPrev}\n          onNext={this._monthNext}\n          onClick={this._showMonthTable}\n        />\n        <MonthTable\n          disableStart={disableStart}\n          disableEnd={disableEnd}\n          month={month}\n          year={year}\n          date={date}\n          onChange={this._onDateChange}\n          selectedOrCurrent={value || this._today}\n        />\n      </div>\n    );\n\n    const YearPickerHolder = (\n      <div className='date_picker_container results transition visible'>\n        <Changer \n          label={null}\n          onPrev={this._pickerYearPrev}\n          onNext={this._pickerYearNext}\n          onClick={() => null}\n        />\n        <YearPicker onSelectYear={this._onSelectYear} year={pickerYear} selectedYear={year}/>\n      </div>\n    );\n\n    const MonthPickerHolder = (\n      <div className='date_picker_container results transition visible'>\n        <MonthPicker onSelectMonth={this._onSelectMonth} selectedMonth={this._monthArray[month]} />\n      </div>\n    );\n\n    let Picker;\n    if (showMonth) {\n      Picker = MonthPickerHolder;\n    } else if (showYear) {\n      Picker = YearPickerHolder;\n    } else {\n      Picker = DatePickerHolder;\n    }\n\n    const Trigger = <Input\n      fluid\n      icon='calendar'\n      iconPosition='left'\n      value={value}\n      onClick={this._onClick}\n    />;\n\n    return (\n      <Popup\n        trigger={Trigger}\n        content={Picker}\n        on='click'\n        open={popupOpen}\n        onClose={this._handleClose}\n        basic\n        style={{padding: 0}}\n        verticalOffset={-10}\n      />\n    );\n  }\n}","import React from \"react\";\nimport { Form, Grid, Message } from \"semantic-ui-react\";\nimport { debounce, uniqBy, isEqual } from 'lodash';\n\n// import FileHandler from './FormFileHandler';\nimport DatePicker from './Calendar/DatePicker';\nimport {\n  getErrorList,\n  getFormGridStruct,\n  getValidatorMap,\n  getDefaultState,\n  convertToArray,\n  runValidation,\n  isRequired,\n} from '../utils';\n\nexport default class GenericForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = getDefaultState(props);\n    this.handleDynamicSearchChange = debounce(this.handleDynamicSearchChange.bind(this), 500);\n    this.getFormUnit = this.getFormUnit.bind(this);\n    props.onChange(this.state);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (!isEqual(prevState, this.state)) {\n      const { onChange } = this.props;\n      onChange(this.state);\n    }\n  }\n\n  // eslint-disable-next-line\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (!isEqual(nextProps, this.props)) {\n      const newState = getDefaultState(nextProps);\n      this.setState(newState);\n    }\n  }\n\n  /**\n   * @values an array or a string representing the values that need validations\n   * @validators an array of validators or an object with type and params or a custom funtion\n   */\n  validateInput = (values, validators, prevState, name, fieldName) => {\n    if(!validators || (Array.isArray(validators) && !validators.length)) return prevState.errors;\n    return { ...prevState.errors, [name]: runValidation(values, validators, fieldName) };\n  }\n\n  onAdvanceChange = (name, value) => {\n    this.setState(prevState => ({\n      formData: { ...prevState.formData, [name]: value },\n    }));\n  }\n\n  handleInputChange = (e, { name, value, validators, fieldName }) => this.setState(prevState => ({\n    formData: { ...prevState.formData, [name]: value },\n    errors: this.validateInput(value, validators, prevState, name, fieldName)\n  }));\n\n  handleCheckChange = (e, { name, value, checked }) => this.setState(prevState => ({\n    formData: {\n      ...prevState.formData,\n      [name]: {\n        value: { ...prevState.formData[name].value, [value]: checked },\n        selected: convertToArray({ ...prevState.formData[name].value, [value]: checked }),\n      }\n    }\n  }));\n\n  handleDropdownChange = (e, { name, value, validators, multiple, options, fieldName }) => {\n    let selectedOptions;\n    let values;\n    if (multiple) {\n      selectedOptions = options.filter(o => value.includes(o.value));\n      values = selectedOptions.map(so => so && so.text);\n    } else {\n      // eslint-disable-next-line prefer-destructuring\n      selectedOptions = options.filter(o => o.value === value)[0];\n      values = selectedOptions && selectedOptions.text;\n    }\n    this.setState(prevState => ({\n      formData: { ...prevState.formData, [name]: { value, selected: selectedOptions } },\n      errors: this.validateInput(values, validators, prevState, name, fieldName),\n    }));\n  };\n\n  addNewDropdownItem = (e, { name, value, multiple, validators, fieldName }) => {\n    if (multiple) {\n      throw new Error('Adding new elements with multiple dropdown not supported yet');\n    }\n    const { dynamicOptions } = this.state;\n    const currentOption = {text: value, value: -1};\n    dynamicOptions[name].options = [...dynamicOptions[name].options, currentOption ];\n\n    this.setState(prevState => ({\n      formData: { ...prevState.formData, [name]: { value: currentOption.value, selected: currentOption } },\n      errors: this.validateInput(value, validators, prevState, name, fieldName),\n      dynamicOptions,\n    }));\n  }\n\n  handleFileChange = (fileObject, { name }) => {\n    this.setState(prevState => ({\n      formData: { ...prevState.formData, [name]: fileObject },\n    }));\n  }\n\n  async handleDynamicSearchChange(e, { name, multiple, searchQuery }) {\n    if (!searchQuery.length) return;\n    const { dynamicOptions, formData } = this.state;\n    dynamicOptions[name].loading = true;\n    this.setState({ dynamicOptions });\n    let newOptions;\n    try {\n      newOptions = await dynamicOptions[name].callback(searchQuery);\n    } catch {\n      newOptions = [];\n    }\n    const oldOptions = formData[name].selected || [];\n    if (multiple) {\n      dynamicOptions[name].options = uniqBy([ ...newOptions, ...oldOptions ], 'value');\n    } else {\n      dynamicOptions[name].options = newOptions;\n    }\n    dynamicOptions[name].loading = false;\n    this.setState({ dynamicOptions });\n  }\n\n  getFormUnit(val) {\n    const { formData, errors, dynamicOptions } = this.state;\n\n    if (val.type === 'hidden' || (val.config && val.config.visible === false)) {\n      return null;\n    }if (val.type === 'input') {\n      return (\n        <Form.Input\n          key={val.dataId}\n          required={isRequired(val.validators)}\n          validators={val.validators}\n          name={val.dataId}\n          fieldName={val.fieldName}\n          label={val.fieldName}\n          value={formData[val.dataId] || ''}\n          error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          onChange={this.handleInputChange}\n          disabled={val.config && val.config.disabled}\n          {...((val.config && val.config.props) || {})}\n        />\n      );\n    } if (val.type === 'dropdown') {\n        if (val.config && val.config.search) {\n          return (\n            <Form.Dropdown\n              key={val.dataId}\n              label={val.fieldName}\n              name={val.dataId}\n              fieldName={val.fieldName}\n              options={dynamicOptions[val.dataId].options}\n              multiple={val.config && val.config.multiple}\n              clearable={val.config && val.config.clearable}\n              selection\n              search\n              placeholder={val.placeholder}\n              value={(formData[val.dataId] || {}).value}\n              onChange={this.handleDropdownChange}\n              onSearchChange={this.handleDynamicSearchChange}\n              disabled={(val.config && val.config.disabled) || dynamicOptions[val.dataId].loading}\n              loading={dynamicOptions[val.dataId].loading}\n              onAddItem={this.addNewDropdownItem}\n              allowAdditions={(val.config && val.config.allowAdditions)}\n              validators={val.validators}\n              error={!!(errors[val.dataId] && errors[val.dataId].length)}\n              required={isRequired(val.validators)}\n            />\n          );\n        }\n        return (\n          <Form.Dropdown\n            key={val.dataId}\n            label={val.fieldName}\n            name={val.dataId}\n            fieldName={val.fieldName}\n            options={val.options}\n            multiple={val.config && val.config.multiple}\n            clearable={val.config && val.config.clearable}\n            selection\n            placeholder={val.placeholder}\n            value={(formData[val.dataId] || {}).value}\n            onChange={this.handleDropdownChange}\n            disabled={val.config && val.config.disabled}\n            onAddItem={this.addNewDropdownItem}\n            allowAdditions={(val.config && val.config.allowAdditions)}\n            loading={val.config && val.config.loading}\n            validators={val.validators}\n            error={!!(errors[val.dataId] && errors[val.dataId].length)}\n            required={isRequired(val.validators)}\n          />\n        );\n    } if (val.type === 'radio') {\n      return (\n        <Form.Group key={val.dataId}>\n          <Form.Field> {val.fieldName}</Form.Field>\n          {val.options.map(radio => (\n              <Form.Radio\n                key={radio.value}\n                label={radio.text}\n                name={val.dataId}\n                fieldName={val.fieldName}\n                value={radio.value}\n                checked={formData[val.dataId] === radio.value}\n                onChange={this.handleInputChange}\n                validators={val.validators}\n                error={!!(errors[val.dataId] && errors[val.dataId].length)}\n              />\n            ))}\n        </Form.Group>\n      );\n    } if (val.type === 'checkbox') {\n      return (\n        <Form.Group key={val.dataId}>\n          <Form.Field> {val.fieldName}</Form.Field>\n          {val.options.map(check => (\n            <Form.Checkbox\n              key={check.value}\n              label={check.text}\n              name={val.dataId}\n              fieldName={val.fieldName}\n              value={check.value}\n              checked={!!((formData[val.dataId] || {}).value || {})[check.value]}\n              onChange={this.handleCheckChange}\n              validators={val.validators}\n              error={!!(errors[val.dataId] && errors[val.dataId].length)}\n            />\n          ))}\n        </Form.Group>\n      );\n    } if (val.type === 'textarea') {\n      return (\n        <Form.TextArea\n          key={val.dataId}\n          required={isRequired(val.validators)}\n          name={val.dataId}\n          fieldName={val.fieldName}\n          label={val.fieldName}\n          value={formData[val.dataId] || ''}\n          error={!!(errors[val.dataId] && errors[val.dataId].length)}\n          onChange={this.handleInputChange}\n          validators={val.validators}\n        />\n      );\n    } if (val.type === 'date') {\n      return (\n        <React.Fragment key={val.dataId}>\n          <Form.Field required={isRequired(val.validators)} error={!!(errors[val.dataId] && errors[val.dataId].length)}>\n            <label>{val.fieldName}</label>\n            <DatePicker\n              key={val.dataId}\n              name={val.dataId}\n              fieldName={val.fieldName}\n              value={formData[val.dataId]}\n              onDateChange={this.handleInputChange}\n              validators={val.validators}\n              {...((val.config && val.config.props) || {})}\n            />\n          </Form.Field>\n        </React.Fragment>\n      );\n    } \n    // if (val.type === 'files') {\n    //   return (\n    //     <FileHandler \n    //       key={val.dataId}\n    //       name={val.dataId}\n    //       fieldName={val.fieldName}\n    //       folderPath={val.folderPath}\n    //       files={formData[val.dataId].files || []}\n    //       onChange={this.handleFileChange}\n    //       header={val.fieldName}\n    //       validators={val.validators}\n    //       error={!!(errors[val.dataId] && errors[val.dataId].length)}\n    //       required={isRequired(val.validators)}\n    //       {...((val.config && val.config.props) || {})}\n    //     />\n    //   );\n    // }\n    return <div>Improper Config</div>;\n  }\n\n  validateForm = async () => {\n    const { errors: currentErrors, formData: formState } = this.state;\n    const { data: form } = this.props;\n    // If error exists return\n    if(Object.values(currentErrors).some(s => s.length)) return true;\n    const validatorMap = getValidatorMap(form, formState);\n    const errors = {};\n    validatorMap.forEach(vm => {\n      if (vm.validators) {\n        errors[vm.id] = runValidation(vm.value, vm.validators, vm.name);\n      }\n    });\n    // We want to set the state first before making the final return of the function\n    return new Promise((resolve) => {\n      this.setState({ errors }, () => {\n        const hasError = !!Object.values(errors).some(s => s.length);\n        resolve(hasError);\n      });\n    })\n  };\n\n  renderGrid(data, columns) {\n    const gridList = getFormGridStruct(data, columns);\n    const firstRowLength = (gridList[0] || []).length;\n    const actualColumns = columns < firstRowLength ? columns : firstRowLength;\n    return (\n      <Grid columns={actualColumns} divided padded>\n        {gridList.map((gl) => (\n          <Grid.Row key={gl.id}>\n            {gl.map((gr) => (\n              <Grid.Column key={gr.id}>{this.getFormUnit(gr)}</Grid.Column>\n            ))}\n          </Grid.Row>\n        ))}\n      </Grid>\n    );\n  }\n\n  render() {\n    const { errors } = this.state;\n    const { data, loading, columns } = this.props;\n\n    const isColumnView = columns > 1;\n\n    return (\n      <Form loading={!!loading} error={(errors && Object.values(errors).some(s => s.length))}>\n        <Message\n          error\n          header='Please check the form for the following'\n          list={getErrorList(errors)}\n        />\n        {isColumnView ? this.renderGrid(data, columns) : data.map(val => this.getFormUnit(val))}\n      </Form>\n    );\n  }\n}\n","import React from 'react';\nimport { isEqual } from 'lodash';\n\nimport FormDisplay from './FormDisplay';\nimport { getDefaultValues } from '../utils';\n\n/**\n * GenericConditionalForm component renders a form which can be conditional on the current data\n * @props (onChange): OPTIONAL: Function called whenever a formState changes\n * @props (form): the form whose format is very specfic: FormType\n * @props (defaultValues): OPTIONAL: To set the initial values of the form\n * @props (errors): OPTIONAL: To set the initial errors of the form\n * type FormType = (defaultValues: DefaultValues) => {\n *    title: String\n *    data: Array<FormUnit>\n * }\n * \n * type DefaultValues = {[ dataId: String]: { defaultValue: String | { value: Array | String, selected: Array<Textvaluepair> | TextValuePair }, options?: Array<TextValuePair> }}\n * type FormUnit = {\n *    fieldName: String,\n *    dataId: String,\n *    type: 'input' | 'checkbox' | 'dropdown' | 'radio' | 'files' | 'hidden' | 'textarea' | 'date' | 'paymentTerms',\n *    config: Object<any>,\n *    defaultValue: DefaultValue,\n *    validation?: String,\n *    options?: Array<TextValuePair>,\n * }\n * Send the form as a function which only accepts defaultValue object and fill out the rest\n */\n\nexport class Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      defaultValues: props.defaultValues || {},\n      prevValues: {},\n      errors: props.errors || {},\n      loading: false,\n    };\n    this.formRef = React.createRef();\n    this.onChange = this.onChange.bind(this);\n    this.updateForm = this.updateForm.bind(this);\n    this.validateForm = this.validateForm.bind(this);\n  }\n\n  async onChange({ formData, errors }) {\n    const { defaultValues, formData: oldFormData, errors: oldErrors } = this.state;\n    if (isEqual(oldFormData, formData) && isEqual(errors, oldErrors)) return;\n    const { data: form, reSyncValues } = this.props;\n    const prevForm = form(defaultValues);\n    let newDefaultValues = getDefaultValues(prevForm, formData);\n    let finalErrors = errors;\n    let loading = false;\n    if (reSyncValues) {\n      try {\n        loading = true;\n        this.updateForm(newDefaultValues, defaultValues, finalErrors, formData, loading);\n        const { values, errors: newErrors } = await reSyncValues(newDefaultValues, defaultValues, errors, formData, this.updateForm);\n        loading = false;\n        newDefaultValues = values;\n        finalErrors = newErrors;\n      } catch (e) {\n        loading = false;\n        finalErrors.generic = true;\n      }\n    }\n    \n    this.updateForm(newDefaultValues, defaultValues, finalErrors, formData, loading);\n  }\n\n  validateForm() {\n    return this.formRef.current.validateForm();\n  }\n\n  updateForm(defaultValues, prevValues, errors, formData, loading) {\n    const { onChange } = this.props;\n\n    this.setState({\n      defaultValues,\n      prevValues,\n      errors,\n      formData,\n      loading,\n    });\n    if (onChange) {\n      onChange({ formData, errors });\n    }\n  }\n\n  render() {\n    const { errors, defaultValues, prevValues, loading } = this.state;\n    const { data: form, columns } = this.props;\n    const currentForm = form(defaultValues, prevValues);\n    return (\n      <FormDisplay\n        columns={columns}\n        data={currentForm}\n        onChange={this.onChange}\n        errors={errors}\n        loading={loading}\n        ref={this.formRef}\n      />\n    );\n  }\n}\n","import { BaseFormConfig } from 'react-generic-form';\r\n\r\nexport class ExampleBasicForm extends BaseFormConfig {\r\n  title = 'Basic Example'\r\n\r\n  data = (currValue, prevValues) => {\r\n    return [\r\n      {\r\n        dataId: 'id',\r\n        type: 'hidden',\r\n        defaultValue: null,\r\n      },\r\n      {\r\n        fieldName: 'Date',\r\n        dataId: 'date',\r\n        type: 'date',\r\n        defaultValue: currValue.from && currValue.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldName: 'Name',\r\n        dataId: 'name',\r\n        type: 'input',\r\n        defaultValue: currValue.name && currValue.name.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldName: 'TextArea',\r\n        dataId: 'textarea',\r\n        type: 'textarea',\r\n        defaultValue: currValue.textarea && currValue.textarea.defaultValue,\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldName: 'Dropdown',\r\n        dataId: 'dropdown',\r\n        type: 'dropdown',\r\n        defaultValue: currValue.dropdown && currValue.dropdown.defaultValue,\r\n        config: {\r\n          clearable: true,\r\n        },\r\n        options: [\r\n          { text: 'Option1', value: 1 },\r\n          { text: 'Option2', value: 2 },\r\n        ],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldName: 'Checkbox',\r\n        dataId: 'checkbox',\r\n        type: 'checkbox',\r\n        defaultValue: currValue.checkbox && currValue.checkbox.defaultValue,\r\n        options: [\r\n          { text: 'Checkbox1', value: 1 },\r\n          { text: 'Checkbox2', value: 2 },\r\n        ],\r\n        validators: [{ type: 'required' }],\r\n      },\r\n      {\r\n        fieldName: 'Radio',\r\n        dataId: 'radio',\r\n        type: 'radio',\r\n        defaultValue: currValue.radio && currValue.radio.defaultValue,\r\n        options: [\r\n          { text: 'Radio1', value: 1 },\r\n          { text: 'Radio2', value: 2 },\r\n          { text: 'Radio3', value: 3 },\r\n        ],\r\n      },\r\n    ];\r\n  }\r\n}\r\n","import React from 'react';\nimport { Form } from 'react-generic-form';\n\nimport { ExampleBasicForm } from './FormConfig';\n\nimport 'react-generic-form/dist/index.css';\nimport 'semantic-ui-css/semantic.min.css';\n\nconst style = {\n  container: {\n    display: 'flex',\n    justifyContent: 'center',\n  },\n  formContainer: {\n    width: '400px',\n  }\n};\n\nexport default () => {\n  const exampleForm = new ExampleBasicForm(); \n  \n  return (\n    <div style={style.container}>\n      <div style={style.formContainer}>\n        <Form\n          data={exampleForm.data}\n        />\n      </div>\n    </div>\n  );\n} \n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}